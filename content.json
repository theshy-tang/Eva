{"meta":{"title":"安得广厦千万间，大庇天下寒士俱欢颜","subtitle":"","description":"第一个博客","author":"TangYongao","url":"https://www.tangyongao.top","root":"/"},"pages":[{"title":"","date":"2022-10-12T09:06:04.975Z","updated":"2022-10-12T09:06:04.975Z","comments":true,"path":"about/index.html","permalink":"https://www.tangyongao.top/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2022-10-11T09:46:21.116Z","updated":"2022-10-11T09:46:21.116Z","comments":true,"path":"categories/index.html","permalink":"https://www.tangyongao.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-10-11T09:37:35.032Z","updated":"2022-10-11T09:37:35.032Z","comments":true,"path":"tags/index.html","permalink":"https://www.tangyongao.top/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-03-10T15:42:13.418Z","updated":"2023-03-10T15:42:13.418Z","comments":true,"path":"friends/index.html","permalink":"https://www.tangyongao.top/friends/index.html","excerpt":"","text":"这里写友链上方的内容。 group: # 分组标题description: # 分组描述items: title: # 名称avatar: # 头像url: # 链接screenshot: # 截图keywords: # 关键词description: # 描述 title: # 名称avatar: # 头像url: # 链接screenshot: # 截图keywords: # 关键词description: # 描述 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"Git","slug":"git学习笔记","date":"2023-03-10T10:26:14.438Z","updated":"2023-03-10T10:29:29.780Z","comments":true,"path":"2023/03/10/git学习笔记/","link":"","permalink":"https://www.tangyongao.top/2023/03/10/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"git学习笔记 12345git add 文件名 [从工作区添加文件到临时区]git rm --cached 文件名 [删除文件]git rm --cached chapt14/ -r [删除文件夹]git reflog ,git log [查看日志信息，后者会详细一些] git commit -m &quot;你想给这个版本的起的名字&quot; 文件名 [提交到本地库] 1$ git reset --hard &quot;版本号&quot; [版本穿梭(也就是返回想要返回的版本)] 12345git branch - v [查看分支]git branch 分支名 [创建分支]git checkout 分支名 [切换分支]cat 文件名 [文件内容]git merge 分支名 [合并分支] 1234git remote -v [查看远程库别名]git remote add [别名] [远程库链接][给远程库起别名]git push [远程库别名] 分支名 [提交代码到远程库]git pull [远程库别名] 分支名 [拉去远程库代码] 1ssh-keygen -t rsa -C github账号邮箱 [ssh免密登录] 视频学习","categories":[{"name":"Git","slug":"Git","permalink":"https://www.tangyongao.top/categories/Git/"}],"tags":[{"name":"Git笔记","slug":"Git笔记","permalink":"https://www.tangyongao.top/tags/Git%E7%AC%94%E8%AE%B0/"}],"author":["唐 某 某"]},{"title":"Linux笔记","slug":"linux","date":"2023-03-09T05:42:41.846Z","updated":"2023-03-09T05:46:54.920Z","comments":true,"path":"2023/03/09/linux/","link":"","permalink":"https://www.tangyongao.top/2023/03/09/linux/","excerpt":"","text":"linuxlinux内核 liunux目录结构 命令行、命令 命令的基础格式 ls命令 ls -a ls -l ls -h 命令可以组合使用，lh必须组合使用，不然莫得意义 home目录和家目录 cd命令 pwd命令 相对路径和绝对路径 特殊路径符 mkdir命令 mkdir -p 注意：创建文件夹需要修改权限，请确保操作均在HOME目录内，不要在HOME外操作涉及到权限问题，HOME外无法成功 touch创建文件 清屏ctrl + L 如何分辨分件和文件夹输入ls -l ，文件开头会有drwxr-xr-x 这样的修饰，这样的就是文件夹，-rw-rw-r–这样的就是文件 cat命令，查看文件内容（查看内容少） more命令，查看文件内容(查看内容多使用） cp命令复制文件夹 mv移动文件或文件夹 rm删除文件、文件夹 rm通配符 which命令 find命令：按文件名查找文件 find命令：按文件大小查找文件 grep命令 wc命令做数量统计 管道符 echo命令 反引号&#96; 重定向符 tail命令 vi\\vim编辑器介绍 命令快捷键 底线命令模式 root用户(超级管理员) su和exit命令 sudo命令 为普通用户配置sudo认证 用户组、用户 进入管理员，创建用户组 groupadd 用户组名，删除用户组 groupdel 用户组名 getent查看组中的用户和组 认知权限信息 rwx的意思 chmod命令(修改文件或文件夹的权限) 权限数字序号 chown(修改文件、文件夹的所属用户和用户组) ctrl + c 强制停止 Ctrl + d 历史命令 光标移动快捷键 yum命令(cenOs7 安装软件) apt(Ubuntu 安装软件) systemctl命令 软链接（类似创建快捷方式） date命令 修改linux时区 修改主机名 域名解析 配置固定ip ping命令 wget命令 curl命令 端口 查看端口占用 查看进程 关闭进程 查看资源占用 top命令选项 top 交互式选项 磁盘的信息监控 网络状态监控 环境变量 $符号 设置环境变量 上传、下载 压缩、解压文件","categories":[{"name":"linux","slug":"linux","permalink":"https://www.tangyongao.top/categories/linux/"}],"tags":[{"name":"Linux笔记","slug":"Linux笔记","permalink":"https://www.tangyongao.top/tags/Linux%E7%AC%94%E8%AE%B0/"}],"author":["唐永澳"]},{"title":"Linux学习笔记","slug":"Linux课程笔记","date":"2023-03-09T05:31:47.381Z","updated":"2023-03-09T05:43:10.391Z","comments":true,"path":"2023/03/09/Linux课程笔记/","link":"","permalink":"https://www.tangyongao.top/2023/03/09/Linux%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Linux基础命令Linux的目录结构 /，根目录是最顶级的目录了 Linux只有一个顶级目录：/ 路径描述的层次关系同样适用/来表示 &#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt ls命令功能：列出文件夹信息 语法：ls [-l -h -a] [参数] 参数：被查看的文件夹，不提供参数，表示查看当前工作目录 -l，以列表形式查看 -h，配合-l，以更加人性化的方式显示文件大小 -a，显示隐藏文件 隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。 默认不显示出来，需要-a选项才可查看到。 pwd命令功能：展示当前工作目录 语法：pwd cd命令功能：切换工作目录 语法：cd [目标目录] 参数：目标目录，要切换去的地方，不提供默认切换到当前登录用户HOME目录 HOME目录每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。 普通用户的HOME目录，默认在：/home/用户名 root用户的HOME目录，在：/root FinalShell登陆终端后，默认的工作目录就是用户的HOME目录 相对路径、绝对路径 相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;/开头的称之为相对路径 相对路径表示以当前目录作为起点，去描述路径，如test/a.txt，表示当前工作目录内的test文件夹内的a.txt文件 绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;/开头的称之为绝对路径 绝对路径从根开始描述路径 特殊路径符 .，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的a.txt文件 ..，表示上级目录，比如../表示上级目录，../../表示上级的上级目录 ~，表示用户的HOME目录，比如cd ~，即可切回用户HOME目录 mkdir命令功能：创建文件夹 语法：mkdir [-p] 参数 参数：被创建文件夹的路径 选项：-p，可选，表示创建前置路径 touch命令功能：创建文件 语法：touch 参数 参数：被创建的文件路径 cat命令功能：查看文件内容 语法：cat 参数 参数：被查看的文件路径 more命令功能：查看文件，可以支持翻页查看 语法：more 参数 参数：被查看的文件路径 在查看过程中： 空格键翻页 q退出查看 cp命令功能：复制文件、文件夹 语法：cp [-r] 参数1 参数2 参数1，被复制的 参数2，要复制去的地方 选项：-r，可选，复制文件夹使用 示例： cp a.txt b.txt，复制当前目录下a.txt为b.txt cp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内 cp -r test test2，复制文件夹test到当前文件夹内为test2存在 mv命令功能：移动文件、文件夹 语法：mv 参数1 参数2 参数1：被移动的 参数2：要移动去的地方，参数2如果不存在，则会进行改名 rm命令功能：删除文件、文件夹 语法：rm [-r -f] 参数...参数 参数：支持多个，每一个表示被删除的，空格进行分隔 选项：-r，删除文件夹使用 选项：-f，强制删除，不会给出确认提示，一般root用户会用到 rm命令很危险，一定要注意，特别是切换到root用户的时候。 which命令功能：查看命令的程序本体文件路径 语法：which 参数 参数：被查看的命令 find命令功能：搜索文件 语法1按文件名搜索：find 路径 -name 参数 路径，搜索的起始路径 参数，搜索的关键字，支持通配符*， 比如：*test表示搜索任意以test结尾的文件 grep命令功能：过滤关键字 语法：grep [-n] 关键字 文件路径 选项-n，可选，表示在结果中显示匹配的行的行号。 参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来 参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口 参数文件路径，可以作为管道符的输入 wc命令功能：统计 语法：wc [-c -m -l -w] 文件路径 选项，-c，统计bytes数量 选项，-m，统计字符数量 选项，-l，统计行数 选项，-w，统计单词数量 参数，文件路径，被统计的文件，可作为内容输入端口 参数文件路径，可作为管道符的输入 管道符|写法：| 功能：将符号左边的结果，作为符号右边的输入 示例： cat a.txt | grep itheima，将cat a.txt的结果，作为grep命令的输入，用来过滤itheima关键字 可以支持嵌套： cat a.txt | grep itheima | grep itcast echo命令功能：输出内容 语法：echo 参数 参数：被输出的内容 &#96;反引号功能：被两个反引号包围的内容，会作为命令执行 示例： echo `pwd`，会输出当前工作目录 tail命令功能：查看文件尾部内容 语法：tail [-f] 参数 参数：被查看的文件 选项：-f，持续跟踪文件修改 head命令功能：查看文件头部内容 语法：head [-n] 参数 参数：被查看的文件 选项：-n，查看的行数 重定向符功能：将符号左边的结果，输出到右边指定的文件中去 &gt;，表示覆盖输出 &gt;&gt;，表示追加输出 vi编辑器命令模式快捷键 底线命令快捷键 命令的选项我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。 比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。 课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。 课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。 查看命令的帮助可以通过：命令 --help查看命令的帮助手册 查看命令的详细手册可以通过：man 命令查看某命令的详细手册 Linux常用操作软件安装 CentOS系统使用： yum [install remove search] [-y] 软件名称 install 安装 remove 卸载 search 搜索 -y，自动确认 Ubuntu系统使用 apt [install remove search] [-y] 软件名称 install 安装 remove 卸载 search 搜索 -y，自动确认 yum 和 apt 均需要root权限 systemctl功能：控制系统服务的启动关闭等 语法：systemctl start | stop | restart | disable | enable | status 服务名 start，启动 stop，停止 status，查看状态 disable，关闭开机自启 enable，开启开机自启 restart，重启 软链接功能：创建文件、文件夹软链接（快捷方式） 语法：ln -s 参数1 参数2 参数1：被链接的 参数2：要链接去的地方（快捷方式的名称和存放位置） 日期语法：date [-d] [+格式化字符串] -d 按照给定的字符串显示日期，一般用于日期计算 格式化字符串：通过特定的字符串标记，来控制显示的日期格式 %Y 年%y 年份后两位数字 (00..99) %m 月份 (01..12) %d 日 (01..31) %H 小时 (00..23) %M 分钟 (00..59) %S 秒 (00..60) %s 自 1970-01-01 00:00:00 UTC 到现在的秒数 示例： 按照2022-01-01的格式显示日期 按照2022-01-01 10:00:00的格式显示日期 -d选项日期计算 支持的时间标记为： 时区修改时区为中国时区 ntp功能：同步时间 安装：yum install -y ntp 启动管理：systemctl start | stop | restart | status | disable | enable ntpd 手动校准时间：ntpdate -u ntp.aliyun.com ip地址格式：a.b.c.d abcd为0~255的数字 特殊IP： 127.0.0.1，表示本机 0.0.0.0 可以表示本机 也可以表示任意IP（看使用场景） 查看ip：ifconfig 主机名功能：Linux系统的名称 查看：hostname 设置：hostnamectl set-hostname 主机名 配置VMware固定IP 修改VMware网络，参阅PPT，图太多 设置Linux内部固定IP 修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33 示例文件内容： 12345678910111213141516171819TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; # 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot; # IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot; # 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot; # 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot; # DNS1服务器，和网关一致即可 ps命令功能：查看进程信息 语法：ps -ef，查看全部进程信息，可以搭配grep做过滤：ps -ef | grep xxx kill命令 nmap命令 netstat命令功能：查看端口占用 用法：netstat -anp | grep xxx ping命令测试网络是否联通 语法：ping [-c num] 参数 wget命令 curl命令 top命令功能：查看主机运行状态 语法：top，查看基础信息 可用选项： 交互式模式中，可用快捷键： df命令查看磁盘占用 iostat命令查看CPU、磁盘的相关信息 sar命令查看网络统计 环境变量 临时设置：export 变量名&#x3D;变量值 永久设置： 针对用户，设置用户HOME目录内：.bashrc文件 针对全局，设置/etc/profile PATH变量记录了执行程序的搜索路径 可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果 $符号可以取出指定的环境变量的值 语法：$变量名 示例： echo $PATH，输出PATH环境变量的值 echo $&#123;PATH&#125;ABC，输出PATH环境变量的值以及ABC 如果变量名和其它内容混淆在一起，可以使用${} 压缩解压压缩tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N -z表示使用gzip，可以不写 zip [-r] 参数1 参数2 参数N 解压tar -zxvf 被解压的文件 -C 要解压去的地方 -z表示使用gzip，可以省略 -C，可以省略，指定要解压去的地方，不写解压到当前目录 unzip [-d] 参数 su命令切换用户 语法：su [-] [用户] sudo命令 比如： 1itheima ALL=(ALL) NOPASSWD: ALL 在visudo内配置如上内容，可以让itheima用户，无需密码直接使用sudo chmod命令修改文件、文件夹权限 语法：chmod [-R] 权限 参数 权限，要设置的权限，比如755，表示：rwxr-xr-x 参数，被修改的文件、文件夹 选项-R，设置文件夹和其内部全部内容一样生效 chown命令修改文件、文件夹所属用户、组 语法：chown [-R] [用户][:][用户组] 文件或文件夹 用户组管理 用户管理 genenv命令 getenv group，查看系统全部的用户组 getenv passwd，查看系统全部的用户 env命令查看系统全部的环境变量 语法：env","categories":[{"name":"linux","slug":"linux","permalink":"https://www.tangyongao.top/categories/linux/"}],"tags":[{"name":"Linux笔记","slug":"Linux笔记","permalink":"https://www.tangyongao.top/tags/Linux%E7%AC%94%E8%AE%B0/"}],"author":["Internet"]},{"title":"Linux软件安装笔记","slug":"Linux系统软件安装","date":"2023-03-09T05:31:43.918Z","updated":"2023-03-09T05:44:30.833Z","comments":true,"path":"2023/03/09/Linux系统软件安装/","link":"","permalink":"https://www.tangyongao.top/2023/03/09/Linux%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/","excerpt":"","text":"实战章节：在Linux上部署各类软件前言为什么学习各类软件在Linux上的部署在前面，我们学习了许多的Linux命令和高级技巧，这些知识点比较零散，同学们跟随着课程的内容进行练习虽然可以基础掌握这些命令和技巧的使用，但是并没有一些具体的实操能够串联起来这些知识点。 所以，现在我们设计了各类软件在Linux上部署安装的实战章节，可以让同学们： 对前面学习的各类操作命令进行复习和练习，从而深度掌握它们 本章节中演示部署的软件，包含了IT行业各类岗位中所必须使用的，如：Java后台、大数据开发、运维开发、测试、AI等。无论学习Linux后从事什么岗位，这些内容都会给你带来帮助 对于零基础学员，实战课程中所讲解的软件大概率多数大家并不了解。 所以，课程仅涉及到安装部署，不对软件的使用做详细说明。 同学们在这个过程中，可能会遇到各种各样的错误，不要怕，解决它，将会给你带来极大的提升。 学习目标对于本部分的内容学习，我们设计两个目标： 对于零基础或未从业的学员，不要求深入理解所安装部署的软件是什么，仅仅能够跟随课程成功的将其部署安装并运行成功即可 在这个过程中，主要锻炼大家对Linux操作系统的熟练度，此乃零基础未从业学员的第一学习目标 对于有基础或已从业的学员，本章节讲解的软件涵盖了大多数IT从业者所能接触到的，特别是大数据开发、后端开发两个主流方向，可以作为参考资料，以便在工作中有所帮助。 本章节内的各类软件安装，&#x3D;&#x3D;不强制要求全部学习&#x3D;&#x3D; 零基础学员，建议全部学习，作为前面学习内容的总结和实战 IT从业者、有经验学员，可以按需选择，选择工作中需要用到的进行学习 章节内包含的软件并非100%涵盖了IT开发领域中所需要的内容。 如果您对某些软件的安装有强烈需求，且课程中没有提供教程，可以私信B站：”黑马大数据曹老师”，老师会酌情根据时间安排补充上去哦。 为什么不使用PPT而是使用文档进行授课从现在开始，将要进入到Linux的实操阶段，在这个阶段我们将会涉及到非常多的软件部署等操作，涉及到： 各类命令的使用 各种过程的结果 复杂的流程步骤 等 这些信息的展示，并不适合于使用PPT作为载体进行授课，所以从现在开始我们将使用操作文档的模式为大家进行讲解。 使用文档模式还有一个好处，除了学习视频以外，拿到课程中使用的操作文档，同样可以作为重要的参考手册进行使用。 一举两得 前置要求 实战章节要求同学们&#x3D;&#x3D;务必全部学习前面的知识点&#x3D;&#x3D;，即：初识Linux、Linux基础命令、Linux权限管理、Linux高阶技巧这4个章节，请勿跳过前面的章节学习实战章节。 实战章节中会开启多台虚拟机，请尽量确保电脑的内存在：8GB（包含8GB）以上。如内存不足可以扩充内存条或购买阿里云、UCloud等云服务器临时使用（1个月多台低配服务器几十块左右） 对于云平台上购买服务器，可以参阅最后的章节（云服务） 注意下面全部的软件安装的相关流程，90%都是取自软件自身的官方网站。 一个合格的程序员要有良好的信息收集能力哦 MySQL数据库管理系统安装部署【简单】简介MySQL数据库管理系统（后续简称MySQL），是一款知名的数据库系统，其特点是：轻量、简单、功能丰富。 MySQL数据库可谓是软件行业的明星产品，无论是后端开发、大数据、AI、运维、测试等各类岗位，基本上都会和MySQL打交道。 让我们从MySQL开始，进行实战的Linux软件安装部署。 本次课程分为2个版本进行安装： MySQL 5.7版本安装 MySQL 8.x版本安装 由于MySQL5.x和8.x各自有许多使用者，所以这两个版本我们都演示安装一遍 注意MySQL的安装过程中，除了会使用Linux命令外，还会使用到少量的数据库专用的：SQL语句 对于SQL语句我们并未涉及，所以可以跟随教程的内容，复制粘贴即可 如对MySQL感兴趣，可以学习BiliBili黑马程序员视频：2022新版黑马程序员MySQL知识精讲+mysql实战案例_零基础mysql数据库入门到高级全套教程 如有时间，建议可以在学习完Linux系统之后，学习一下MySQL数据库 无论从事什么方面的开发，Java后端、大数据、AI、前端、Linux运维等，都会要求掌握MySQL数据库的 可以说，MySQL是IT开发从业者必备的技能了。 MySQL5.7版本在CentOS系统安装 注意：安装操作需要root权限 MySQL的安装我们可以通过前面学习的yum命令进行。 安装 配置yum仓库 12345# 更新密钥rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022# 安装Mysql yum库rpm -Uvh http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 由于MySQL并不在CentOS的官方仓库中，所以我们通过上述rpm命令： 导入MySQL仓库的密钥 配置MySQLQ的yum仓库 使用yum安装MySQL 12# yum安装Mysqlyum -y install mysql-community-server 安装完成后，启动MySQL并配置开机自启动 12systemctl start mysqld # 启动systemctl enable mysqld # 开机自启 MySQL安装完成后，会自动配置为名称叫做：mysqld的服务，可以被systemctl所管理 检查MySQL的运行状态 1systemctl status mysqld 配置主要配置管理员用户root的密码以及配置允许远程登录的权限。 获取MySQL的初始密码 12# 通过grep命令，在/var/log/mysqld.log文件中，过滤temporary password关键字，得到初始密码grep &#x27;temporary password&#x27; /var/log/mysqld.log 登陆MySQL数据库系统 1234567# 执行mysql -uroot -p# 解释# -u，登陆的用户，MySQL数据库的管理员用户同Linux一样，是root# -p，表示使用密码登陆# 执行完毕后输入刚刚得到的初始密码，即可进入MySQL数据库 修改root用户密码 12# 在MySQL控制台内执行ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;密码&#x27;; -- 密码需要符合：大于8位，有大写字母，有特殊符号，不能是连续的简单语句如123，abc [扩展]，配置root的简单密码 我们可以给root设置简单密码，如123456. 请注意，此配置仅仅是用于测试环境或学习环境的MySQL，如果是正式使用，请勿设置简单密码 123456# 如果你想设置简单密码，需要降低Mysql的密码安全级别set global validate_password_policy=LOW; # 密码安全级别低set global validate_password_length=4; # 密码长度最低4位即可# 然后就可以用简单密码了（课程中使用简单密码，为了方便，生产中不要这样）ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;简单密码&#x27;; [扩展]，配置root运行远程登录 默认情况下，root用户是不运行远程登录的，只允许在MySQL所在的Linux服务器登陆MySQL系统 请注意，允许root远程登录会带来安全风险 1234567# 授权root远程登录grant all privileges on *.* to root@&quot;IP地址&quot; identified by &#x27;密码&#x27; with grant option; # IP地址即允许登陆的IP地址，也可以填写%，表示允许任何地址# 密码表示给远程登录独立设置密码，和本地登陆的密码可以不同# 刷新权限，生效flush privileges; 退出MySQL控制台页面 1234# 退出命令exit# 或者通过快捷键退出：ctrl + d 检查端口 MySQL默认绑定了3306端口，可以通过端口占用检查MySQL的网络状态 1netstat -anp | grep 3306 至此，MySQL就安装完成并可用了，请妥善保存好MySQL的root密码。 MySQL8.0版本在CentOS系统安装 注意：安装操作需要root权限 安装 配置yum仓库 12345# 更新密钥rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022# 安装Mysql8.x版本 yum库rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm 使用yum安装MySQL 12# yum安装Mysqlyum -y install mysql-community-server 安装完成后，启动MySQL并配置开机自启动 12systemctl start mysqld # 启动systemctl enable mysqld # 开机自启 MySQL安装完成后，会自动配置为名称叫做：mysqld的服务，可以被systemctl所管理 检查MySQL的运行状态 1systemctl status mysqld 配置主要修改root密码和允许root远程登录 获取MySQL的初始密码 12# 通过grep命令，在/var/log/mysqld.log文件中，过滤temporary password关键字，得到初始密码grep &#x27;temporary password&#x27; /var/log/mysqld.log 登录MySQL数据库系统 1234567# 执行mysql -uroot -p# 解释# -u，登陆的用户，MySQL数据库的管理员用户同Linux一样，是root# -p，表示使用密码登陆# 执行完毕后输入刚刚得到的初始密码，即可进入MySQL数据库 修改root密码 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;; -- 密码需要符合：大于8位，有大写字母，有特殊符号，不能是连续的简单语句如123，abc [扩展]，配置root的简单密码 我们可以给root设置简单密码，如123456. 请注意，此配置仅仅是用于测试环境或学习环境的MySQL，如果是正式使用，请勿设置简单密码 12set global validate_password.policy=0; # 密码安全级别低set global validate_password.length=4; # 密码长度最低4位即可 允许root远程登录，并设置远程登录密码 默认情况下，root用户是不运行远程登录的，只允许在MySQL所在的Linux服务器登陆MySQL系统 请注意，允许root远程登录会带来安全风险 12345# 第一次设置root远程登录，并配置远程密码使用如下SQL命令create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码!&#x27;; -- 密码需要符合：大于8位，有大写字母，有特殊符号，不能是连续的简单语句如123，abc# 后续修改密码使用如下SQL命令ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;; 退出MySQL控制台页面 1234# 退出命令exit# 或者通过快捷键退出：ctrl + d 检查端口 MySQL默认绑定了3306端口，可以通过端口占用检查MySQL的网络状态 1netstat -anp | grep 3306 至此，MySQL就安装完成并可用了，请妥善保存好MySQL的root密码。 MySQL5.7版本在Ubuntu（WSL环境）系统安装 课程中配置的WSL环境是最新的Ubuntu22.04版本，这个版本的软件商店内置的MySQL是8.0版本 所以我们需要额外的步骤才可以安装5.7版本的MySQL 安装操作需root权限，你可以： 通过 sudo su -，切换到root用户 课程中选择这种方式操作 或在每一个命令前，加上sudo，用来临时提升权限 安装 下载apt仓库文件 12# 下载apt仓库的安装包，Ubuntu的安装包是.deb文件wget https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb 配置apt仓库 12# 使用dpkg命令安装仓库dpkg -i mysql-apt-config_0.8.12-1_all.deb 弹出框中选择：ubuntu bionic （Ubuntu18.04系统的代号是bionic，选择18.04的版本库用来安装） 弹出框中选择：MySQL Server &amp; Cluster 弹出框中选择：mysql-5.7 最后选择：ok 更新apt仓库的信息 1234# 首先导入仓库的密钥信息apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 467B942D3A79BD29# 更新仓库信息apt update 检查是否成功配置MySQL5.7的仓库 1apt-cache policy mysql-server 看到如图所示字样，即成功 安装MySQL5.7 12# 使用apt安装mysql客户端和mysql服务端apt install -f -y mysql-client=5.7* mysql-community-server=5.7* 弹出框中输入root密码并选择ok，密码任意，课程中以123456代替 再次输入root密码确认 启动MySQL 123/etc/init.d/mysql start # 启动/etc/init.d/mysql stop # 停止/etc/init.d/mysql status # 查看状态 对MySQL进行初始化 12345# 执行如下命令，此命令是MySQL安装后自带的配置程序mysql_secure_installation# 可以通过which命令查看到这个自带程序所在的位置root@DESKTOP-Q89USRE:~# which mysql_secure_installation/usr/bin/mysql_secure_installation 输入密码： 是否开启密码验证插件，如果需要增强密码安全性，输入y并回车，不需要直接回车（课程中选择直接回车） 是否更改root密码，需要输入y回车，不需要直接回车（课程不更改） 是否移除匿名用户，移除输入y回车，不移除直接回车（课程选择移除） 是否进制root用户远程登录，禁止输入y回车，不禁止直接回车（课程选择不禁止） 是否移除自带的测试数据库，移除输入y回车，不移除直接回车（课程选择不移除） 是否刷新权限，刷新输入y回车，不刷新直接回车（课程选择刷新） 登陆MySQL 12mysql -uroot -p# 输入密码即可登陆成功 至此，在Ubuntu上安装MySQL5.7版本成功。 MySQL8.0版本在Ubuntu（WSL环境）系统安装 课程中配置的WSL环境是最新的Ubuntu22.04版本，这个版本的软件商店内置的MySQL是8.0版本 所以直接可以通过apt安装即可 注意，课程是以WSL获得的Ubuntu操作系统环境。 如果你通过VMware虚拟机的方式获得了Ubuntu操作系统环境，操作步骤不用担心，和课程中使用WSL环境是&#x3D;&#x3D;完全一致的&#x3D;&#x3D; 安装操作需root权限，你可以： 通过 sudo su -，切换到root用户 课程中选择这种方式操作 或在每一个命令前，加上sudo，用来临时提升权限 安装 如果已经安装过MySQL5.7版本，需要卸载仓库信息哦 12345# 卸载MySQL5.7版本apt remove -y mysql-client=5.7* mysql-community-server=5.7*# 卸载5.7的仓库信息dpkg -l | grep mysql | awk &#x27;&#123;print $2&#125;&#x27; | xargs dpkg -P 更新apt仓库信息 1apt update 安装mysql 1apt install -y mysql-server 启动MySQL 123/etc/init.d/mysql start # 启动/etc/init.d/mysql stop # 停止/etc/init.d/mysql status # 查看状态 登陆MySQL设置密码 12# 直接执行：mysqlmysql 设置密码 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;; 退出MySQL控制台 1exit 对MySQL进行初始化 12345# 执行如下命令，此命令是MySQL安装后自带的配置程序mysql_secure_installation# 可以通过which命令查看到这个自带程序所在的位置root@DESKTOP-Q89USRE:~# which mysql_secure_installation/usr/bin/mysql_secure_installation 输入密码： 是否开启密码验证插件，如果需要增强密码安全性，输入y并回车，不需要直接回车（课程中选择直接回车） 是否更改root密码，需要输入y回车，不需要直接回车（课程不更改） 是否移除匿名用户，移除输入y回车，不移除直接回车（课程选择移除） 是否进制root用户远程登录，禁止输入y回车，不禁止直接回车（课程选择不禁止） 是否移除自带的测试数据库，移除输入y回车，不移除直接回车（课程选择不移除） 是否刷新权限，刷新输入y回车，不刷新直接回车（课程选择刷新） 重新登陆MySQL（用更改后的密码） 1mysql -uroot -p 至此，在Ubuntu上安装MySQL5.7版本成功。 Tomcat安装部署【简单】简介Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。 简单来说，Tomcat是一个WEB应用程序的托管平台，可以让用户编写的WEB应用程序，被Tomcat所托管，并提供网站服务。 即让用户开发的WEB应用程序，变成可以被访问的网页。 安装Tomcat的安装非常简单，主要分为2部分： 安装JDK环境 解压并安装Tomcat 本次安装使用Tomcat版本是：10.0.27版本，需要Java（JDK）版本最低为JDK8或更高版本 课程中使用的JDK版本是：JDK8u351版本 安装JDK环境 下载JDK软件 https://www.oracle.com/java/technologies/downloads 在页面下方找到： 下载jdk-8u351-linux-x64.tar.gz &#x3D;&#x3D;在弹出的页面中输入Oracle的账户密码即可下载（如无账户，请自行注册，注册是免费的）&#x3D;&#x3D; 登陆Linux系统，切换到root用户 通过FinalShell，上传下载好的JDK安装包 创建文件夹，用来部署JDK，将JDK和Tomcat都安装部署到：&#x2F;export&#x2F;server 内 1mkdir -p /export/server 解压缩JDK安装文件 1tar -zxvf jdk-8u351-linux-x64.tar.gz -C /export/server 配置JDK的软链接 1ln -s /export/server/jdk1.8.0_351 /export/server/jdk 配置JAVA_HOME环境变量，以及将$JAVA_HOME&#x2F;bin文件夹加入PATH环境变量中 123# 编辑/etc/profile文件export JAVA_HOME=/export/server/jdkexport PATH=$PATH:$JAVA_HOME/bin 生效环境变量 1source /etc/profile 配置java执行程序的软链接 1234# 删除系统自带的java程序rm -f /usr/bin/java# 软链接我们自己安装的java程序ln -s /export/server/jdk/bin/java /usr/bin/java 执行验证： 12java -versionjavac -version 解压并部署Tomcat Tomcat建议使用非Root用户安装并启动 可以创建一个用户：tomcat用以部署 首先，放行tomcat需要使用的8080端口的外部访问权限 CentOS系统默认开启了防火墙，阻止外部网络流量访问系统内部 所以，如果想要Tomcat可以正常使用，需要对Tomcat默认使用的8080端口进行放行 放行有2种操作方式： 关闭防火墙 配置防火墙规则，放行端口 12345678# 以下操作2选一即可# 方式1：关闭防火墙systemctl stop firewalld # 关闭防火墙systemctl disable firewalld # 停止防火墙开机自启# 方式2：放行8080端口的外部访问firewall-cmd --add-port=8080/tcp --permanent # --add-port=8080/tcp表示放行8080端口的tcp访问，--permanent表示永久生效firewall-cmd --reload # 重新载入防火墙规则使其生效 方便起见，建议同学们选择方式1，直接关闭防火墙一劳永逸 防火墙的配置非常复杂，后面会视情况独立出一集防火墙配置规则的章节。 以root用户操作，创建tomcat用户 1234# 使用root用户操作useradd tomcat# 可选，为tomcat用户配置密码passwd tomcat 下载Tomcat安装包 1234# 使用root用户操作wget https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz# 如果出现https相关错误，可以使用--no-check-certificate选项wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz 如果Linux内下载过慢，可以复制下载链接在Windows系统中使用迅雷等软件加速下载然后上传到Linux内即可 或者使用课程资料中提供的安装包 解压Tomcat安装包 12# 使用root用户操作，否则无权限解压到/export/server内，除非修改此文件夹权限tar -zxvf apache-tomcat-10.0.27.tar.gz -C /export/server 创建Tomcat软链接 12# 使用root用户操作ln -s /export/server/apache-tomcat-10.0.27 /export/server/tomcat 修改tomcat安装目录权限 12# 使用root用户操作，同时对软链接和tomcat安装文件夹进行修改，使用通配符*进行匹配chown -R tomcat:tomcat /export/server/*tomcat* 切换到tomcat用户 1su - tomcat 启动tomcat 1/export/server/tomcat/bin/startup.sh tomcat启动在8080端口，可以检查是否正常启动成功 1netstat -anp | grep 8080 打开浏览器，输入： http://centos:8080或http://192.168.88.130:8080 使用主机名（需配置好本地的主机名映射）或IP地址访问Tomcat的WEB页面 至此，Tomcat安装配置完成。 Nginx安装部署【简单】简介Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。 同Tomcat一样，Nginx可以托管用户编写的WEB应用程序成为可访问的网页服务，同时也可以作为流量代理服务器，控制流量的中转。 Nginx在WEB开发领域，基本上也是必备组件之一了。 安装Nginx同样需要配置额外的yum仓库，才可以使用yum安装 安装Nginx的操作需要root身份 安装yum依赖程序 12# root执行yum install -y yum-utils 手动添加，nginx的yum仓库 yum程序使用的仓库配置文件，存放在：/etc/yum.repo.d内。 12345678910111213141516171819# root执行# 创建文件使用vim编辑vim /etc/yum.repos.d/nginx.repo# 填入如下内容并保存退出[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 通过如上操作，我们手动添加了nginx的yum仓库 通过yum安装最新稳定版的nginx 12# root执行yum install -y nginx 启动 123456# nginx自动注册了systemctl系统服务systemctl start nginx # 启动systemctl stop nginx # 停止systemctl status nginx # 运行状态systemctl enable nginx # 开机自启systemctl disable nginx # 关闭开机自启 配置防火墙放行 nginx默认绑定80端口，需要关闭防火墙或放行80端口 1234567# 方式1（推荐），关闭防火墙systemctl stop firewalld # 关闭systemctl disable firewalld # 关闭开机自启# 方式2，放行80端口firewall-cmd --add-port=80/tcp --permanent # 放行tcp规则下的80端口，永久生效firewall-cmd --reload # 重新加载防火墙规则 启动后浏览器输入Linux服务器的IP地址或主机名即可访问 http://192.168.88.130 或 http://centos ps：80端口是访问网站的默认端口，所以后面无需跟随端口号 显示的指定端口也是可以的比如： http://192.168.88.130:80 http://centos:80 至此，Nginx安装配置完成。 RabbitMQ安装部署【简单】简介RabbitMQ一款知名的开源消息队列系统，为企业提供消息的发布、订阅、点对点传输等消息服务。 RabbitMQ在企业开发中十分常见，课程为大家演示快速搭建RabbitMQ环境。 安装 rabbitmq在yum仓库中的版本比较老，所以我们需要手动构建yum仓库 准备yum仓库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# root执行# 1. 准备gpgkey密钥rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.ascrpm --import https://packagecloud.io/rabbitmq/erlang/gpgkeyrpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey# 2. 准备仓库文件vim /etc/yum.repos.d/rabbitmq.repo# 填入如下内容#### Zero dependency Erlang##[rabbitmq_erlang]name=rabbitmq_erlangbaseurl=https://packagecloud.io/rabbitmq/erlang/el/7/$basearchrepo_gpgcheck=1gpgcheck=1enabled=1# PackageCloud&#x27;s repository key and RabbitMQ package signing keygpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.ascsslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300[rabbitmq_erlang-source]name=rabbitmq_erlang-sourcebaseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMSrepo_gpgcheck=1gpgcheck=0enabled=1# PackageCloud&#x27;s repository key and RabbitMQ package signing keygpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.ascsslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300#### RabbitMQ server##[rabbitmq_server]name=rabbitmq_serverbaseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/$basearchrepo_gpgcheck=1gpgcheck=0enabled=1# PackageCloud&#x27;s repository key and RabbitMQ package signing keygpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.ascsslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300[rabbitmq_server-source]name=rabbitmq_server-sourcebaseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/SRPMSrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300 安装RabbitMQ 12# root执行yum install erlang rabbitmq-server -y 12Installed: erlang.x86_64 0:23.3.4.11-1.el7 rabbitmq-server.noarch 0:3.10.0-1.el7 启动 1234567# root执行# 使用systemctl管控，服务名：rabbitmq-serversystemctl enable rabbitmq-server # 开机自启systemctl disable rabbitmq-server # 关闭开机自启systemctl start rabbitmq-server # 启动systemctl stop rabbitmq-server # 关闭systemctl status rabbitmq-server # 查看状态 放行防火墙，RabbitMQ使用5672、15672、25672 3个端口 123456789# 方式1（推荐），关闭防火墙systemctl stop firewalld # 关闭systemctl disable firewalld # 关闭开机自启# 方式2，放行5672 25672端口firewall-cmd --add-port=5672/tcp --permanent # 放行tcp规则下的5672端口，永久生效firewall-cmd --add-port=15672/tcp --permanent # 放行tcp规则下的15672端口，永久生效firewall-cmd --add-port=25672/tcp --permanent # 放行tcp规则下的25672端口，永久生效firewall-cmd --reload # 重新加载防火墙规则 启动RabbitMQ的WEB管理控制台 1rabbitmq-plugins enable rabbitmq_management 添加admin用户，并赋予权限 123rabbitmqctl add_user admin &#x27;Itheima66^&#x27;rabbitmqctl set_permissions -p &quot;/&quot; &quot;admin&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;rabbitmqctl set_user_tags admin administrator 浏览器打开管理控制台 http://192.168.88.130:15672 至此，RabbitMQ已经安装完成了。 Redis安装部署【简单】简介redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。 redis的特点就是：快，可以基于内存存储数据并提供超低延迟、超快的检索速度 一般用于在系统中提供快速缓存的能力。 安装 配置EPEL仓库 EPEL 的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。EPEL则为服务器版本提供大量的rpm包(yum程序所使用的程序安装包，类似Windows的exe)，而且大多数rpm包在官方 repository 中是找不到的。 12# root执行yum install -y epel-release 安装redis 12# root执行yum install -y redis 启动redis 1234567# root执行# 使用systemctl管控，服务名：redissystemctl enable redis # 开机自启systemctl disable redis # 关闭开机自启systemctl start redis # 启动systemctl stop redis # 关闭systemctl status redis # 查看状态 放行防火墙，redis使用端口6379 1234567# 方式1（推荐），关闭防火墙systemctl stop firewalld # 关闭systemctl disable firewalld # 关闭开机自启# 方式2，放行6379端口firewall-cmd --add-port=6379/tcp --permanent # 放行tcp规则下的6379端口，永久生效firewall-cmd --reload 进入redis服务 1234567# 执行redis-cli[root@centos ~]# redis-cli127.0.0.1:6379&gt; set mykey helloOK127.0.0.1:6379&gt; get mykey&quot;hello&quot;127.0.0.1:6379&gt; 至此，redis安装完成。 ElasticSearch安装部署简介全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 es）是目前全文搜索引擎的首选。 它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。 Elasticsearch简称es，在企业内同样是一款应用非常广泛的搜索引擎服务。 很多服务中的搜索功能，都是基于es来实现的。 安装 添加yum仓库 1234567891011121314151617181920# root执行# 导入仓库密钥rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch# 添加yum源# 编辑文件 vim /etc/yum.repos.d/elasticsearch.repo[elasticsearch-7.x]name=Elasticsearch repository for 7.x packagesbaseurl=https://artifacts.elastic.co/packages/7.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md# 更新yum缓存yum makecache 安装es 1yum install -y elasticsearch 配置es 12345678910111213vim /etc/elasticsearch/elasticsearch.yml# 17行，设置集群名称cluster.name: my-cluster# 23行，设置节点名称node.name: node-1# 56行，允许外网访问network.host: 0.0.0.0# 74行，配置集群master节点cluster.initial_master_nodes: [&quot;node-1&quot;] 启动es 1systemctl start | stop | status | enable | disable elasticsearch 关闭防火墙 12systemctl stop firewalldsystemctl disable firewalld 测试 浏览器打开：http://ip:9200/?pretty 集群化环境前置准备介绍在前面，我们所学习安装的软件，都是以单机模式运行的。 后续，我们将要学习大数据相关的软件部署，所以后续我们所安装的软件服务，大多数都是以集群化（多台服务器共同工作）模式运行的。 所以，在当前小节，我们需要完成集群化环境的前置准备，包括创建多台虚拟机，配置主机名映射，SSH免密登录等等。 部署配置多台Linux虚拟机安装集群化软件，首要条件就是要有多台Linux服务器可用。 我们可以使用VMware提供的克隆功能，将我们的虚拟机额外克隆出3台来使用。 首先，关机当前CentOS系统虚拟机（可以使用root用户执行init 0来快速关机） 新建文件夹 文件夹起名为：虚拟机集群 克隆 同样的操作克隆出：node2和node3 开启node1，修改主机名为node1，并修改固定ip为：192.168.88.131 123456789101112# 修改主机名hostnamectl set-hostname node1# 修改IP地址vim /etc/sysconfig/network-scripts/ifcfg-ens33IPADDR=&quot;192.168.88.131&quot;# 重启网卡systemctl stop networksystemctl start network# 或者直接systemctl restart network 同样的操作启动node2和node3, 修改node2主机名为node2，设置ip为192.168.88.132 修改node2主机名为node3，设置ip为192.168.88.133 配置FinalShell，配置连接到node1、node2、node3的连接 为了简单起见，建议配置root用户登录 准备主机名映射 在Windows系统中修改hosts文件，填入如下内容： 如果同学们使用MacOS系统，请： sudo su -，切换到root 修改&#x2F;etc&#x2F;hosts文件 123192.168.88.131 node1192.168.88.132 node2192.168.88.133 node3 在3台Linux的&#x2F;etc&#x2F;hosts文件中，填入如下内容（&#x3D;&#x3D;3台都要添加&#x3D;&#x3D;） 123192.168.88.131 node1192.168.88.132 node2192.168.88.133 node3 配置SSH免密登录简介SSH服务是一种用于远程登录的安全认证协议。 我们通过FinalShell远程连接到Linux，就是使用的SSH服务。 SSH服务支持： 通过账户+密码的认证方式来做用户认证 通过账户+秘钥文件的方式做用户认证 SSH可以让我们通过SSH命令，远程的登陆到其它的主机上，比如： 在node1执行：ssh root@node2，将以root用户登录node2服务器，输入密码即可成功登陆 或者ssh node2，将以当前用户直接登陆到node2服务器。 SSH免密配置后续安装的集群化软件，多数需要远程登录以及远程执行命令，我们可以简单起见，配置三台Linux服务器之间的免密码互相SSH登陆 在每一台机器都执行：ssh-keygen -t rsa -b 4096，一路回车到底即可 在每一台机器都执行： 123ssh-copy-id node1ssh-copy-id node2ssh-copy-id node3 执行完毕后，node1、node2、node3之间将完成root用户之间的免密互通 配置JDK环境后续的大数据集群软件，多数是需要Java运行环境的，所以我们为&#x3D;&#x3D;每一台&#x3D;&#x3D;机器都配置JDK环境。 JDK配置参阅：Tomcat安装部署环节。 关闭防火墙和SELinux集群化软件之间需要通过端口互相通讯，为了避免出现网络不通的问题，我们可以简单的在集群内部关闭防火墙。 &#x3D;&#x3D;在每一台机器都执行&#x3D;&#x3D; 12systemctl stop firewalldsystemctl disable firewalld Linux有一个安全模块：SELinux，用以限制用户和程序的相关权限，来确保系统的安全稳定。 SELinux的配置同防火墙一样，非常复杂，课程中不多涉及，后续视情况可以出一章SELinux的配置课程。 在当前，我们只需要关闭SELinux功能，避免导致后面的软件运行出现问题即可， &#x3D;&#x3D;在每一台机器都执行&#x3D;&#x3D; 12345vim /etc/sysconfig/selinux# 将第七行，SELINUX=enforcing 改为SELINUX=disabled# 保存退出后，重启虚拟机即可，千万要注意disabled单词不要写错，不然无法启动系统 添加快照为了避免后续出现问题，在完成上述设置后，为&#x3D;&#x3D;每一台虚拟机&#x3D;&#x3D;都制作快照，留待使用。 补充命令 - scp后续的安装部署操作，我们将会频繁的在多台服务器之间相互传输数据。 为了更加方面的互相传输，我们补充一个命令：scp scp命令是cp命令的升级版，即：ssh cp，通过SSH协议完成文件的复制。 其主要的功能就是：在不同的Linux服务器之间，通过SSH协议互相传输文件。 只要知晓服务器的账户和密码（或密钥），即可通过SCP互传文件。 语法： 12345678910111213141516171819scp [-r] 参数1 参数2- -r选项用于复制文件夹使用，如果复制文件夹，必须使用-r- 参数1：本机路径 或 远程目标路径- 参数2：远程目标路径 或 本机路径如：scp -r /export/server/jdk root@node2:/export/server/将本机上的jdk文件夹， 以root的身份复制到node2的/export/server/内同SSH登陆一样，账户名可以省略（使用本机当前的同名账户登陆）如：scp -r node2:/export/server/jdk /export/server/将远程node2的jdk文件夹，复制到本机的/export/server/内# scp命令的高级用法cd /export/serverscp -r jdk node2:`pwd`/ # 将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下scp -r jdk node2:$PWD # 将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下 Zookeeper集群安装部署简介ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 除了为Hadoop和HBase提供协调服务外，Zookeeper也被其它许多软件采用作为其分布式状态一致性的依赖，比如Kafka，又或者一些软件项目中，也经常能见到Zookeeper作为一致性协调服务存在。 Zookeeper不论是大数据领域亦或是其它服务器开发领域，涉及到分布式状态一致性的场景，总有它的身影存在。 安装Zookeeper是一款分布式的集群化软件，可以在多台服务器上部署，并协同组成分布式集群一起工作。 首先，要确保已经完成了集群化环境前置准备环节的全部内容 【node1上操作】下载Zookeeper安装包，并解压 12345678# 下载wget http://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz# 确保如下目录存在，不存在就创建mkdir -p /export/server# 解压tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz -C /export/server 【node1上操作】创建软链接 1ln -s /export/server/apache-zookeeper-3.5.9 /export/server/zookeeper 【node1上操作】修改配置文件 1234567891011vim /export/server/zookeeper/conf/zoo.cfgtickTime=2000# zookeeper数据存储目录dataDir=/export/server/zookeeper/dataclientPort=2181initLimit=5syncLimit=2server.1=node1:2888:3888server.2=node2:2888:3888server.3=node3:2888:3888 【node1上操作】配置myid 123456# 1. 创建Zookeeper的数据目录mkdir /export/server/zookeeper/data# 2. 创建文件，并填入1vim /export/server/zookeeper/data/myid# 在文件内填入1即可 【在node2和node3上操作】，创建文件夹 1mkdir -p /export/server 【node1上操作】将Zookeeper 复制到node2和node3 1234cd /export/serverscp -r apache-zookeeper-3.5.9 node2:`pwd`/scp -r apache-zookeeper-3.5.9 node3:`pwd`/ 【在node2上操作】 123456# 1. 创建软链接ln -s /export/server/apache-zookeeper-3.5.9 /export/server/zookeeper# 2. 修改myid文件vim /export/server/zookeeper/data/myid# 修改内容为2 【在node3上操作】 123456# 1. 创建软链接ln -s /export/server/apache-zookeeper-3.5.9 /export/server/zookeeper# 2. 修改myid文件vim /export/server/zookeeper/data/myid# 修改内容为3 【在node1、node2、node3上分别执行】启动Zookeeper 12# 启动命令/export/server/zookeeper/bin/zkServer.sh start # 启动Zookeeper 【在node1、node2、node3上分别执行】检查Zookeeper进程是否启动 123jps# 结果中找到有：QuorumPeerMain 进程即可 【node1上操作】验证Zookeeper 123456/export/server/zookeeper/zkCli.sh# 进入到Zookeeper控制台中后，执行ls /# 如无报错即配置成功 至此Zookeeper安装完成 Kafka集群安装部署简介Kafka是一款分布式的、去中心化的、高吞吐低延迟、订阅模式的消息队列系统。 同RabbitMQ一样，Kafka也是消息队列。不过RabbitMQ多用于后端系统，因其更加专注于消息的延迟和容错。 Kafka多用于大数据体系，因其更加专注于数据的吞吐能力。 Kafka多数都是运行在分布式（集群化）模式下，所以课程将以3台服务器，来完成Kafka集群的安装部署。 安装 确保已经跟随前面的视频，安装并部署了JDK和Zookeeper服务 Kafka的运行依赖JDK环境和Zookeeper请确保已经有了JDK环境和Zookeeper 【在node1操作】下载并上传Kafka的安装包 12# 下载安装包wget http://archive.apache.org/dist/kafka/2.4.1/kafka_2.12-2.4.1.tgz 【在node1操作】解压 1234567mkdir -p /export/server # 此文件夹如果不存在需先创建# 解压tar -zxvf kafka_2.12-2.4.1.tgz -C /export/server/# 创建软链接ln -s /export/server/kafka_2.12-2.4.1 /export/server/kafka 【在node1操作】修改Kafka目录内的config目录内的server.properties文件 123456789cd /export/server/kafka/config# 指定broker的idbroker.id=1# 指定 kafka的绑定监听的地址listeners=PLAINTEXT://node1:9092# 指定Kafka数据的位置log.dirs=/export/server/kafka/data# 指定Zookeeper的三个节点zookeeper.connect=node1:2181,node2:2181,node3:2181 【在node1操作】将node1的kafka复制到node2和node3 123456cd /export/server# 复制到node2同名文件夹scp -r kafka_2.12-2.4.1 node2:`pwd`/# 复制到node3同名文件夹scp -r kafka_2.12-2.4.1 node3:$PWD 【在node2操作】 123456789101112# 创建软链接ln -s /export/server/kafka_2.12-2.4.1 /export/server/kafkacd /export/server/kafka/config# 指定broker的idbroker.id=2# 指定 kafka的绑定监听的地址listeners=PLAINTEXT://node2:9092# 指定Kafka数据的位置log.dirs=/export/server/kafka/data# 指定Zookeeper的三个节点zookeeper.connect=node1:2181,node2:2181,node3:2181 【在node3操作】 123456789101112# 创建软链接ln -s /export/server/kafka_2.12-2.4.1 /export/server/kafkacd /export/server/kafka/config# 指定broker的idbroker.id=3# 指定 kafka的绑定监听的地址listeners=PLAINTEXT://node3:9092# 指定Kafka数据的位置log.dirs=/export/server/kafka/data# 指定Zookeeper的三个节点zookeeper.connect=node1:2181,node2:2181,node3:2181 启动kafka 1234567# 请先确保Zookeeper已经启动了# 方式1：【前台启动】分别在node1、2、3上执行如下语句/export/server/kafka/bin/kafka-server-start.sh /export/server/kafka/config/server.properties# 方式2：【后台启动】分别在node1、2、3上执行如下语句nohup /export/server/kafka/bin/kafka-server-start.sh /export/server/kafka/config/server.properties 2&gt;&amp;1 &gt;&gt; /export/server/kafka/kafka-server.log &amp; 验证Kafka启动 12# 在每一台服务器执行jps 测试Kafka能否正常使用 创建测试主题 12# 在node1执行，创建一个主题/export/server/kafka_2.12-2.4.1/bin/kafka-topics.sh --create --zookeeper node1:2181 --replication-factor 1 --partitions 3 --topic test 运行测试，请在FinalShell中打开2个node1的终端页面 1234# 打开一个终端页面，启动一个模拟的数据生产者/export/server/kafka_2.12-2.4.1/bin/kafka-console-producer.sh --broker-list node1:9092 --topic test# 再打开一个新的终端页面，在启动一个模拟的数据消费者/export/server/kafka_2.12-2.4.1/bin/kafka-console-consumer.sh --bootstrap-server node1:9092 --topic test --from-beginning 大数据集群（Hadoop生态）安装部署简介1）Hadoop是一个由Apache基金会所开发的分布式系统基础架构。2）主要解决，海量数据的存储和海量数据的分析计算问题。 Hadoop HDFS 提供分布式海量数据存储能力 Hadoop YARN 提供分布式集群资源管理能力 Hadoop MapReduce 提供分布式海量数据计算能力 前置要求 请确保完成了集群化环境前置准备章节的内容 即：JDK、SSH免密、关闭防火墙、配置主机名映射等前置操作 Hadoop集群角色Hadoop生态体系中总共会出现如下进程角色： Hadoop HDFS的管理角色：Namenode进程（仅需1个即可（管理者一个就够）） Hadoop HDFS的工作角色：Datanode进程（需要多个（工人，越多越好，一个机器启动一个）） Hadoop YARN的管理角色：ResourceManager进程（仅需1个即可（管理者一个就够）） Hadoop YARN的工作角色：NodeManager进程（需要多个（工人，越多越好，一个机器启动一个）） Hadoop 历史记录服务器角色：HistoryServer进程（仅需1个即可（功能进程无需太多1个足够）） Hadoop 代理服务器角色：WebProxyServer进程（仅需1个即可（功能进程无需太多1个足够）） Zookeeper的进程：QuorumPeerMain进程（仅需1个即可（Zookeeper的工作者，越多越好）） 角色和节点分配角色分配如下： node1:Namenode、Datanode、ResourceManager、NodeManager、HistoryServer、WebProxyServer、QuorumPeerMain node2:Datanode、NodeManager、QuorumPeerMain node3:Datanode、NodeManager、QuorumPeerMain 安装调整虚拟机内存如上图，可以看出node1承载了太多的压力。同时node2和node3也同时运行了不少程序 为了确保集群的稳定，需要对虚拟机进行内存设置。 请在VMware中，对： node1设置4GB或以上内存 node2和node3设置2GB或以上内存 大数据的软件本身就是集群化（一堆服务器）一起运行的。 现在我们在一台电脑中以多台虚拟机来模拟集群，确实会有很大的内存压力哦。 Zookeeper集群部署略 Hadoop集群部署 下载Hadoop安装包、解压、配置软链接 123456789# 1. 下载wget http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz# 2. 解压# 请确保目录/export/server存在tar -zxvf hadoop-3.3.0.tar.gz -C /export/server/# 3. 构建软链接ln -s /export/server/hadoop-3.3.0 /export/server/hadoop 修改配置文件：hadoop-env.sh Hadoop的配置文件要修改的地方很多，请细心 cd 进入到&#x2F;export&#x2F;server&#x2F;hadoop&#x2F;etc&#x2F;hadoop，文件夹中，配置文件都在这里 修改hadoop-env.sh文件 此文件是配置一些Hadoop用到的环境变量 这些是临时变量，在Hadoop运行时有用 如果要永久生效，需要写到&#x2F;etc&#x2F;profile中 123456789101112131415161718192021# 在文件开头加入：# 配置Java安装路径export JAVA_HOME=/export/server/jdk# 配置Hadoop安装路径export HADOOP_HOME=/export/server/hadoop# Hadoop hdfs配置文件路径export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop# Hadoop YARN配置文件路径export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop# Hadoop YARN 日志文件夹export YARN_LOG_DIR=$HADOOP_HOME/logs/yarn# Hadoop hdfs 日志文件夹export HADOOP_LOG_DIR=$HADOOP_HOME/logs/hdfs# Hadoop的使用启动用户配置export HDFS_NAMENODE_USER=rootexport HDFS_DATANODE_USER=rootexport HDFS_SECONDARYNAMENODE_USER=rootexport YARN_RESOURCEMANAGER_USER=rootexport YARN_NODEMANAGER_USER=rootexport YARN_PROXYSERVER_USER=root 修改配置文件：core-site.xml 如下，清空文件，填入如下内容 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node1:8020&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;131072&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 配置：hdfs-site.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir.perm&lt;/name&gt; &lt;value&gt;700&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/data/nn&lt;/value&gt; &lt;description&gt;Path on the local filesystem where the NameNode stores the namespace and transactions logs persistently.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.hosts&lt;/name&gt; &lt;value&gt;node1,node2,node3&lt;/value&gt; &lt;description&gt;List of permitted DataNodes.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.blocksize&lt;/name&gt; &lt;value&gt;268435456&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.handler.count&lt;/name&gt; &lt;value&gt;100&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/data/dn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置：mapred-env.sh文件 1234# 在文件的开头加入如下环境变量设置export JAVA_HOME=/export/server/jdkexport HADOOP_JOB_HISTORYSERVER_HEAPSIZE=1000export HADOOP_MAPRED_ROOT_LOGGER=INFO,RFA 配置：mapred-site.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;node1:10020&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;node1:19888&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.intermediate-done-dir&lt;/name&gt; &lt;value&gt;/data/mr-history/tmp&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.done-dir&lt;/name&gt; &lt;value&gt;/data/mr-history/done&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_HOME&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_HOME&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_HOME&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 配置：yarn-env.sh文件 1234567# 在文件的开头加入如下环境变量设置export JAVA_HOME=/export/server/jdkexport HADOOP_HOME=/export/server/hadoopexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoopexport YARN_CONF_DIR=$HADOOP_HOME/etc/hadoopexport YARN_LOG_DIR=$HADOOP_HOME/logs/yarnexport HADOOP_LOG_DIR=$HADOOP_HOME/logs/hdfs 配置：yarn-site.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt;&lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://node1:19888/jobhistory/logs&lt;/value&gt; &lt;description&gt;&lt;/description&gt;&lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.web-proxy.address&lt;/name&gt; &lt;value&gt;node1:8089&lt;/value&gt; &lt;description&gt;proxy server hostname and port&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;description&gt;Configuration to enable or disable log aggregation&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt; &lt;value&gt;/tmp/logs&lt;/value&gt; &lt;description&gt;Configuration to enable or disable log aggregation&lt;/description&gt; &lt;/property&gt;&lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node1&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt; &lt;value&gt;/data/nm-local&lt;/value&gt; &lt;description&gt;Comma-separated list of paths on the local filesystem where intermediate data is written.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.log-dirs&lt;/name&gt; &lt;value&gt;/data/nm-log&lt;/value&gt; &lt;description&gt;Comma-separated list of paths on the local filesystem where logs are written.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.log.retain-seconds&lt;/name&gt; &lt;value&gt;10800&lt;/value&gt; &lt;description&gt;Default time (in seconds) to retain log files on the NodeManager Only applicable if log-aggregation is disabled.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;description&gt;Shuffle service that needs to be set for Map Reduce applications.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 修改workers文件 1234# 全部内容如下node1node2node3 分发hadoop到其它机器 12345# 在node1执行cd /export/serverscp -r hadoop-3.3.0 node2:`pwd`/scp -r hadoop-3.3.0 node2:`pwd`/ 在node2、node3执行 12# 创建软链接ln -s /export/server/hadoop-3.3.0 /export/server/hadoop 创建所需目录 在node1执行： 1234mkdir -p /data/nnmkdir -p /data/dnmkdir -p /data/nm-logmkdir -p /data/nm-local 在node2执行： 123mkdir -p /data/dnmkdir -p /data/nm-logmkdir -p /data/nm-local 在node3执行： 123mkdir -p /data/dnmkdir -p /data/nm-logmkdir -p /data/nm-local 配置环境变量 在node1、node2、node3修改&#x2F;etc&#x2F;profile 12export HADOOP_HOME=/export/server/hadoopexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 执行source /etc/profile生效 格式化NameNode，在node1执行 1hadoop namenode -format hadoop这个命令来自于：$HADOOP_HOME&#x2F;bin中的程序 由于配置了环境变量PATH，所以可以在任意位置执行hadoop命令哦 启动hadoop的hdfs集群，在node1执行即可 1234start-dfs.sh# 如需停止可以执行stop-dfs.sh start-dfs.sh这个命令来自于：$HADOOP_HOME&#x2F;sbin中的程序 由于配置了环境变量PATH，所以可以在任意位置执行start-dfs.sh命令哦 启动hadoop的yarn集群，在node1执行即可 1234start-yarn.sh# 如需停止可以执行stop-yarn.sh 启动历史服务器 123mapred --daemon start historyserver# 如需停止将start更换为stop 启动web代理服务器 123yarn-daemon.sh start proxyserver# 如需停止将start更换为stop 验证Hadoop集群运行情况 在node1、node2、node3上通过jps验证进程是否都启动成功 验证HDFS，浏览器打开：http://node1:9870 创建文件test.txt，随意填入内容，并执行： 123hadoop fs -put test.txt /test.txthadoop fs -cat /test.txt 验证YARN，浏览器打开：http://node1:8088 执行： 12345678910# 创建文件words.txt，填入如下内容itheima itcast hadoopitheima hadoop hadoopitheima itcast# 将文件上传到HDFS中hadoop fs -put words.txt /words.txt# 执行如下命令验证YARN是否正常hadoop jar /export/server/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.0.jar wordcount -Dmapred.job.queue.name=root.root /words.txt /output 大数据NoSQL数据库HBase集群部署简介HBase 是一种分布式、可扩展、支持海量数据存储的 NoSQL 数据库。 和Redis一样，HBase是一款KeyValue型存储的数据库。 不过和Redis设计方向不同 Redis设计为少量数据，超快检索 HBase设计为海量数据，快速检索 HBase在大数据领域应用十分广泛，现在我们来在node1、node2、node3上部署HBase集群。 安装 HBase依赖Zookeeper、JDK、Hadoop（HDFS），请确保已经完成前面 集群化软件前置准备（JDK） Zookeeper Hadoop 这些环节的软件安装 【node1执行】下载HBase安装包 12345678# 下载wget http://archive.apache.org/dist/hbase/2.1.0/hbase-2.1.0-bin.tar.gz# 解压tar -zxvf hbase-2.1.0-bin.tar.gz -C /export/server# 配置软链接ln -s /export/server/hbase-2.1.0 /export/server/hbase 【node1执行】，修改配置文件，修改conf/hbase-env.sh文件 1234567# 在28行配置JAVA_HOMEexport JAVA_HOME=/export/server/jdk# 在126行配置：# 意思表示，不使用HBase自带的Zookeeper，而是用独立Zookeeperexport HBASE_MANAGES_ZK=false# 在任意行，比如26行，添加如下内容：export HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP=&quot;true&quot; 【node1执行】，修改配置文件，修改conf/hbase-site.xml文件 12345678910111213141516171819202122232425262728# 将文件的全部内容替换成如下内容：&lt;configuration&gt; &lt;!-- HBase数据在HDFS中的存放的路径 --&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://node1:8020/hbase&lt;/value&gt; &lt;/property&gt; &lt;!-- Hbase的运行模式。false是单机模式，true是分布式模式。若为false,Hbase和Zookeeper会运行在同一个JVM里面 --&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- ZooKeeper的地址 --&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;node1,node2,node3&lt;/value&gt; &lt;/property&gt; &lt;!-- ZooKeeper快照的存储位置 --&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/export/server/apache-zookeeper-3.6.0-bin/data&lt;/value&gt; &lt;/property&gt; &lt;!-- V2.1版本，在分布式情况下, 设置为false --&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 【node1执行】，修改配置文件，修改conf/regionservers文件 1234# 填入如下内容node1node2node3 【node1执行】，分发hbase到其它机器 12scp -r /export/server/hbase-2.1.0 node2:/export/server/scp -r /export/server/hbase-2.1.0 node3:/export/server/ 【node2、node3执行】，配置软链接 1ln -s /export/server/hbase-2.1.0 /export/server/hbase 【node1、node2、node3执行】，配置环境变量 12345# 配置在/etc/profile内，追加如下两行export HBASE_HOME=/export/server/hbaseexport PATH=$HBASE_HOME/bin:$PATHsource /etc/profile 【node1执行】启动HBase 请确保：Hadoop HDFS、Zookeeper是已经启动了的 1234start-hbase.sh# 如需停止可使用stop-hbase.sh 由于我们配置了环境变量export PATH&#x3D;$PATH:$HBASE_HOME&#x2F;bin start-hbase.sh即在$HBASE_HOME&#x2F;bin内，所以可以无论当前目录在哪，均可直接执行 验证HBase 浏览器打开：http://node1:16010，即可看到HBase的WEB UI页面 简单测试使用HBase 【node1执行】 12345678910111213hbase shell# 创建表create &#x27;test&#x27;, &#x27;cf&#x27;# 插入数据put &#x27;test&#x27;, &#x27;rk001&#x27;, &#x27;cf:info&#x27;, &#x27;itheima&#x27;# 查询数据get &#x27;test&#x27;, &#x27;rk001&#x27;# 扫描表数据scan &#x27;test&#x27; 分布式内存计算Spark环境部署注意本小节的操作，基于：大数据集群（Hadoop生态）安装部署环节中所构建的Hadoop集群 如果没有Hadoop集群，请参阅前置内容，部署好环境。 简介Spark是一款分布式内存计算引擎，可以支撑海量数据的分布式计算。 Spark在大数据体系是明星产品，作为最新一代的综合计算引擎，支持离线计算和实时计算。 在大数据领域广泛应用，是目前世界上使用最多的大数据分布式计算引擎。 我们将基于前面构建的Hadoop集群，部署Spark Standalone集群。 安装 【node1执行】下载并解压 1234567wget https://archive.apache.org/dist/spark/spark-2.4.5/spark-2.4.5-bin-hadoop2.7.tgz# 解压tar -zxvf spark-2.4.5-bin-hadoop2.7.tgz -C /export/server/# 软链接ln -s /export/server/spark-2.4.5-bin-hadoop2.7 /export/server/spark 【node1执行】修改配置文件名称 1234# 改名cd /export/server/spark/confmv spark-env.sh.template spark-env.shmv slaves.template slaves 【node1执行】修改配置文件，spark-env.sh 1234567891011121314## 设置JAVA安装目录JAVA_HOME=/export/server/jdk## HADOOP软件配置文件目录，读取HDFS上文件和运行YARN集群HADOOP_CONF_DIR=/export/server/hadoop/etc/hadoopYARN_CONF_DIR=/export/server/hadoop/etc/hadoop## 指定spark老大Master的IP和提交任务的通信端口export SPARK_MASTER_HOST=node1export SPARK_MASTER_PORT=7077SPARK_MASTER_WEBUI_PORT=8080SPARK_WORKER_CORES=1SPARK_WORKER_MEMORY=1g 【node1执行】修改配置文件，slaves 123node1node2node3 【node1执行】分发 12scp -r spark-2.4.5-bin-hadoop2.7 node2:$PWDscp -r spark-2.4.5-bin-hadoop2.7 node3:$PWD 【node2、node3执行】设置软链接 1ln -s /export/server/spark-2.4.5-bin-hadoop2.7 /export/server/spark 【node1执行】启动Spark集群 1234/export/server/spark/sbin/start-all.sh# 如需停止，可以/export/server/spark/sbin/stop-all.sh 打开Spark监控页面，浏览器打开：http://node1:8081 【node1执行】提交测试任务 1/export/server/spark/bin/spark-submit --master spark://node1:7077 --class org.apache.spark.examples.SparkPi /export/server/spark/examples/jars/spark-examples_2.11-2.4.5.jar 分布式内存计算Flink环境部署注意本小节的操作，基于：大数据集群（Hadoop生态）安装部署环节中所构建的Hadoop集群 如果没有Hadoop集群，请参阅前置内容，部署好环境。 简介Flink同Spark一样，是一款分布式内存计算引擎，可以支撑海量数据的分布式计算。 Flink在大数据体系同样是明星产品，作为最新一代的综合计算引擎，支持离线计算和实时计算。 在大数据领域广泛应用，是目前世界上除去Spark以外，应用最为广泛的分布式计算引擎。 我们将基于前面构建的Hadoop集群，部署Flink Standalone集群 Spark更加偏向于离线计算而Flink更加偏向于实时计算。 安装 【node1操作】下载安装包 1234567wget https://archive.apache.org/dist/flink/flink-1.10.0/flink-1.10.0-bin-scala_2.11.tgz# 解压tar -zxvf flink-1.10.0-bin-scala_2.11.tgz -C /export/server/# 软链接ln -s /export/server/flink-1.10.0 /export/server/flink 【node1操作】修改配置文件，conf/flink-conf.yaml 12345678910111213141516# jobManager 的IP地址jobmanager.rpc.address: node1# JobManager 的端口号jobmanager.rpc.port: 6123# JobManager JVM heap 内存大小jobmanager.heap.size: 1024m# TaskManager JVM heap 内存大小taskmanager.heap.size: 1024m# 每个 TaskManager 提供的任务 slots 数量大小taskmanager.numberOfTaskSlots: 2#是否进行预分配内存，默认不进行预分配，这样在我们不使用flink集群时候不会占用集群资源taskmanager.memory.preallocate: false# 程序默认并行计算的个数parallelism.default: 1#JobManager的Web界面的端口（默认：8081）jobmanager.web.port: 8081 【node1操作】，修改配置文件，conf/slaves 123node1node2node3 【node1操作】分发Flink安装包到其它机器 123cd /export/serverscp -r flink-1.10.0 node2:`pwd`/scp -r flink-1.10.0 node3:`pwd`/ 【node2、node3操作】 12# 配置软链接ln -s /export/server/flink-1.10.0 /export/server/flink 【node1操作】，启动Flink 1/export/server/flink/bin/start-cluster.sh 验证Flink启动 12# 浏览器打开http://node1:8081 提交测试任务 【node1执行】 1/export/server/flink/bin/flink run /export/server/flink-1.10.0/examples/batch/WordCount.jar 运维监控Zabbix部署简介Zabbix 由 Alexei Vladishev 创建，目前由其成立的公司—— Zabbix SIA 积极的持续开发更新维护， 并为用户提供技术支持服务。 Zabbix 是一个&#x3D;&#x3D;企业级分布式开源监控解决方案&#x3D;&#x3D;。 Zabbix 软件能够&#x3D;&#x3D;监控&#x3D;&#x3D;众多网络参数和服务器的&#x3D;&#x3D;健康度、完整性&#x3D;&#x3D;。Zabbix 使用灵活的告警机制，允许用户为几乎任何事件配置基于邮件的告警。这样用户可以快速响应服务器问题。Zabbix 基于存储的数据提供出色的报表和数据可视化功能。这些功能使得 Zabbix 成为容量规划的理想选择。 安装 安装整体步骤: 准备Linux 服务器(虚拟机) 安装Mysql 安装zabbix( 包含 server agent web) 配置 mysql, 为zabbix创建表结构 配置zabbix server 启动并开启开机自启动 安装前准备 - Mysql安装ZabbixServer需要先安装好Mysql数据库 课程使用Mysql 5.7 安装步骤： 1234567891011121314151617181920212223242526272829# 安装Mysql yum库rpm -Uvh http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm# yum安装Mysqlyum -y install mysql-community-server# 启动Mysql设置开机启动systemctl start mysqldsystemctl enable mysqld# 检查Mysql服务状态systemctl status mysqld# 第一次启动mysql，会在日志文件中生成root用户的一个随机密码，使用下面命令查看该密码grep &#x27;temporary password&#x27; /var/log/mysqld.log# 修改root用户密码mysql -u root -p -h localhostEnter password: mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Root!@#$&#x27;;# 如果你想设置简单密码，需要降低Mysql的密码安全级别set global validate_password_policy=LOW; # 密码安全级别低set global validate_password_length=4; # 密码长度最低4位即可# 然后就可以用简单密码了（课程中使用简单密码，为了方便，生产中不要这样）ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root&#x27;;mysql&gt; grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27;; 安装Zabbix Server 和 Zabbix Agent 初始安装，我们先安装ZabbixServer以及在Server本机安装Agent。 打开官网下载页面：https://www.zabbix.com/download?zabbix=4.0&amp;os_distribution=centos&amp;os_version=7&amp;db=mysql 选择对应的版本，然后再下面官网给出了具体的安装命令，使用rpm和yum来进行安装。 需要有网络。 以下内容来自官方页面 a. 安装Zabbix yum库documentation 12rpm -Uvh https://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-2.el7.noarch.rpmyum clean all b. 安装Zabbix Server、前端、Agent123yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent# 如果只需要安装Agent的话yum -y install zabbix-agent c. 初始化Mysql数据库documentation 在Mysql中操作 123456# 登录Mysql 数据库mysql -uroot -pYourPasswordmysql&gt; create database zabbix character set utf8 collate utf8_bin;mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &#x27;zabbix&#x27;;# 或者: grant all privileges on zabbix.* to zabbix@&#x27;%&#x27; identified by &#x27;zabbix&#x27;;mysql&gt; quit; 测试在Zabbix Server服务器上能否远程登录Mysql，如果可以登录继续向下走。 Import initial schema and data. You will be prompted to enter your newly created password. 1# zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix d. 为Zabbix Server配置数据库Edit file &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf 12DBPassword=passwordDBHost=mysql-host-ip-or-hostname e. 配置Zabbix的PHP前端Edit file /etc/httpd/conf.d/zabbix.conf, uncomment and set the right timezone for you.# php_value date.timezone Asia/Shanghai Start Zabbix server and agent processes and make it start at system boot: 12systemctl restart zabbix-server zabbix-agent httpd # 启动、重启systemctl enable zabbix-server zabbix-agent httpd # 开机自启 Now your Zabbix server is up and running! 配置zabbix 前端（WEB UI）打开:http://192.168.88.131/zabbix 即可进入Zabbix页面，在首次打开的时候，会进入设置页面，如图： 点击下一步，会检查相应的设置是否都正常 如果一切正常，点击下一步。 配置DB连接 按具体情况填写即可 配置Server细节 具体配置即可，Name表示这个Zabbix服务的名字，这里起名叫ITHEIMA-TEST 安装前总结预览 检查确认没有问题就下一步 配置完成 初始管理员账户Admin密码zabbix 输入账户密码后，就能进入zabbix页面了。 如下图： 现在是一个崭新的zabbix等待我们去探索。 运维监控Grafana部署简介安装部署形式Grafana支持两种部署形式 自行部署, 可以部署在操作系统之上. 自行提供服务器, 域名等. Grafana官方托管. 无需安装, 在线注册即可得到一个专属于自己的Grafana, 但是要花钱的. 是一种SaaS服务 我们课程选择方式1 安装Grafana支持常见的绝大多数操作系统, 如windows mac linux 同时也支持部署在docker中. 大多数情况下, Grafana都是部署在linux服务器之上. 所以本课程也是基于Linux系统来讲解. 对windows mac系统 或 docker部署有兴趣的同学, 请参考: https://grafana.com/grafana/download 我们部署Grafana可以使用YUM来进行部署. 12345678910111213141516# 创建一个文件vim /etc/yum.repos.d/grafana.repo# 将下面的内容复制进去[grafana]name=grafanabaseurl=https://packages.grafana.com/oss/rpmrepo_gpgcheck=1enabled=1gpgcheck=1gpgkey=https://packages.grafana.com/gpg.keysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crt# 最后安装yum install grafana 配置说明grafana-server具有许多配置选项，这些选项可以在.ini配置文件中指定，也可以使用环境变量指定。 Note. Grafana needs to be restarted for any configuration changes to take effect. 配置文件注释;符号在.ini文件中全局表示注释 () 配置文件路径如果是自己解压安装, 或者自行编译的方式安装, 配置文件在: 默认: $WORKING_DIR/conf/defaults.ini 自定义:$WORKING_DIR/conf/custom.ini 自定义配置文件路径可以被参数--config覆盖 对于YUM RPM 安装的方式, 配置文件在: /etc/grafana/grafana.ini 使用环境变量可以使用以下语法使用环境变量来覆盖配置文件中的所有选项： 1GF_&lt;SectionName&gt;_&lt;KeyName&gt; 其中SectionName是方括号内的文本。一切都应为大写，.应替换为_ 例如，给定以下配置设置： 12345678# default sectioninstance_name = $&#123;HOSTNAME&#125;[security]admin_user = admin[auth.google]client_secret = 0ldS3cretKey Then you can override them using: 123export GF_DEFAULT_INSTANCE_NAME=my-instanceexport GF_SECURITY_ADMIN_USER=true # GF_ 固定 SECURITY 是SectionName ADMIN_USER 是配置的key 转大写 . 转 _export GF_AUTH_GOOGLE_CLIENT_SECRET=newS3cretKey 开始配置Grafana支持使用Sqlite3 Postgresql Mysql这三种数据库作为其元数据的存储. 我们课程使用Mysql. 和zabbix的元数据mysql共用一个实例 只需要配置如下内容即可: 并登陆mysql, 执行: create database grafana CHARACTER SET utf8 COLLATE utf8_general_ci; 创建Grafana使用的数据库作为元数据存储. 启动123systemctl daemon-reloadsystemctl start grafana-serversystemctl enable grafana-server 浏览器打开：http://node1:3000 默认账户密码：admin&#x2F;admin","categories":[{"name":"linux","slug":"linux","permalink":"https://www.tangyongao.top/categories/linux/"}],"tags":[{"name":"Linux软件安装","slug":"Linux软件安装","permalink":"https://www.tangyongao.top/tags/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"author":["Internet"]},{"title":"Typora","slug":"Typora使用","date":"2023-03-08T03:15:41.464Z","updated":"2023-03-08T03:24:42.425Z","comments":true,"path":"2023/03/08/Typora使用/","link":"","permalink":"https://www.tangyongao.top/2023/03/08/Typora%E4%BD%BF%E7%94%A8/","excerpt":"","text":"markdown的使用说明一、标题 语法：# (一级标题) ## (二级标题) ### (三级标题) …… 代码： 12&gt;# 这是一级标题&gt;## 这是二级标题 效果: 这是一级标题这是二级标题 快捷键: Ctrl+数字1~6可以快速将选中的文本调成对应级别的标题 Ctrl+0可以快速将选中的文本调成普通文本 Ctrl+加号&#x2F;减号对标题级别进行加减 二、段落1、换行 代码: 12&gt;这是一个段落&gt;这是一个段落 效果: 这是一个段落这是一个段落 2、分割线 语法: —或者***+回车 代码: 1&gt;---或者*** 效果: 三、文字显示1、字体 语法: 粗体: 用一对双星号包裹 删除线: 用一对双飘号包裹 下划线: 用一对u标签包裹 斜体: 用一对单星号包裹 高亮: 用一对双等号包裹 代码: 12345&gt;**这是粗体**&gt;~~这是删除线~~&gt;&lt;u&gt;这是下划线&lt;/u&gt;&gt;*这是斜体*&gt;==这是高亮== 效果:这是粗体这是删除线这是下划线这是斜体&#x3D;&#x3D;这是高亮&#x3D;&#x3D; 快捷键: 加粗: Ctrl+B 删除线: Shift+Alt+5 下划线: Ctrl+U 斜体: Ctrl+I 2、上下标 代码: 12&gt;x^2^&gt;H~2~O 效果:x^2^H2O 四、列表1、无序列表 代码: 1&gt;*/-/+ +空格 效果:1.只有同一级别: 苹果 香蕉 橘子 2.子集类: 一级分类 二级分类 三级分类 快捷键: Ctrl+Shift+] 2、有序列表 代码: 1&gt;数字+.+空格 效果: 第一个标题 第二个标题 第三个标题 子内容1 子内容2 第四个标题 快捷键: Ctrl+Shift+[ 3、任务列表 代码: 12&gt;- [ ] 吃早餐&gt;- [x] 背单词 效果: 吃早餐 背单词 五、区块显示 代码: 1&gt;&gt;+回车 效果: 这是最外层区块 这是内层区块 这是最内层区块 六、代码显示1、行内代码 代码: 1&gt;`int a=0;`（说明：`位于Esc下面） 效果:int a=0; 快捷键: Ctrl+Shift+&#96; 2、代码块 代码: 123&gt;```js/java/c#/text&gt;内容&gt;``` 快捷键: Ctrl+Shift+K 七、链接 代码: 123&gt;www.baidu.com&gt;[百度一下](https://www.baidu.com)&gt;[百度一下](https://www.baidu.com &quot;https://www.baidu.com&quot;) 效果:www.baidu.com百度一下百度一下 快捷键: Ctrl+K 八、脚注 说明: 对文本进行解释说明。 代码: 12&gt;[^文本]&gt;[^文本]:解释说明 效果:这是一个技术^① 九、图片插入 代码: 1&gt;![不显示的文字](图片路径 &quot;图片标题&quot;) 效果:![This is a picture](C:\\Users\\asus\\Pictures\\Saved Pictures\\Snipaste_2020-09-03_13-19-11.png “漫步图”) (注：效果路径为C:\\Users\\asus\\Pictures\\Saved Pictures\\Snipaste_2020-09-03_13-19-11.png。在其他电脑上可能不显示。) 快捷键: Ctrl+Shift+I 十、表格 代码: 12345&gt;| 1 | 2 | 3 |&gt;| :--- | :--: | ---: |&gt;| 4 | 5 | 6 |&gt;| 7 | 8 | 9 |&gt;| 10 | 11 | 12 | 效果: 1 2 3 4 5 6 7 8 9 10 11 12 快捷键: Ctrl+T 十一、流程图1、横向流程图 代码: 12345678```mermaidgraph LRA[方形]==&gt;B(圆角)B==&gt;C&#123;条件a&#125;C--&gt;|a=1|D[结果1]C--&gt;|a=2|E[结果2]F[横向流程图]``` 效果: 123456&gt;graph LR&gt;A[方形]==&gt;B(圆角)&gt;B==&gt;C&#123;条件a&#125;&gt;C--&gt;|a=1|D[结果1]&gt;C--&gt;|a=2|E[结果2]&gt;F[横向流程图] 2、竖向流程图 代码: 12345678```mermaid&gt;graph TD&gt;A[方形]==&gt;B(圆角)&gt;B==&gt;C&#123;条件a&#125;&gt;C--&gt;|a=1|D[结果1]&gt;C--&gt;|a=2|E[结果2]&gt;F[竖向流程图]&gt;``` 效果: 123456&gt;graph TD&gt;A[方形]==&gt;B(圆角)&gt;B==&gt;C&#123;条件a&#125;&gt;C--&gt;|a=1|D[结果1]&gt;C--&gt;|a=2|E[结果2]&gt;F[竖向流程图] 十二、表情符号 代码: 1&gt;:happy:、:cry:、:man: 效果::happy:、 :cry:、 :man: 十三、数学公式的输入1、公式的插入①行中公式 代码: 1&gt;$公式$ 效果:$公式$ ②独立公式 代码: 123&gt;$$&gt;公式&gt;$$ 效果:$$公式$$ 2、上下标 代码: 12&gt;$x^&#123;y^z&#125;=(1+e^x)^&#123;-2xy^w&#125;$&gt;$\\sideset&#123;^1_2&#125;&#123;^3_4&#125;&#123;\\underset&#123;6&#125;\\bigotimes&#125;$ 效果:$x^{y^z}&#x3D;(1+e^x)^{-2xy^w}$$\\sideset{^1_2}{^3_4}{\\underset{6}\\bigotimes}$ 3、括号和分隔符 代码: 123&gt;$\\langle\\quad\\rangle\\quad\\lceil\\quad\\rceil\\quad\\lfloor\\quad\\rfloor\\quad\\lbrace\\quad\\rbrace\\quad\\lVert\\quad\\rVert$&gt;$f(x,y,z)=3y^2z\\left(3+\\dfrac&#123;7x+5&#125;&#123;1+y^2&#125;\\right)$&gt;$\\left.\\dfrac&#123;\\mathrm&#123;d&#125;u&#125;&#123;\\mathrm&#123;d&#125;x&#125;\\right|_&#123;x=0&#125;$ 效果:$\\langle\\quad\\rangle\\quad\\lceil\\quad\\rceil\\quad\\lfloor\\quad\\rfloor\\quad\\lbrace\\quad\\rbrace\\quad\\lVert\\quad\\rVert$$f(x,y,z)&#x3D;3y^2z\\left(3+\\dfrac{7x+5}{1+y^2}\\right)$$\\left.\\dfrac{\\mathrm{d}u}{\\mathrm{d}x}\\right|_{x&#x3D;0}$ 4、分数 代码: 1&gt;$\\frac&#123;a&#125;&#123;b&#125;\\quad\\dfrac&#123;a&#125;&#123;b&#125;\\quad &#123;a\\over b&#125;$ 效果:$\\frac{a}{b}\\quad\\dfrac{a}{b}\\quad {a\\over b}$ 5、开方 代码: 1&gt;$\\sqrt[根指数,省略时为2]&#123;被开方数&#125;$ 效果:$\\sqrt{2}\\quad\\sqrt[3]{2}$ 6、省略号 代码: 1&gt;$\\cdots\\quad\\ldots\\quad\\vdots\\quad\\ddots$ 效果:$\\cdots\\quad\\ldots\\quad\\vdots\\quad\\ddots$ 7、矢量和均值 代码: 1&gt;$\\overrightarrow&#123;E(\\vec&#123;r&#125;)&#125;\\quad\\overleftarrow&#123;E(\\vec&#123;r&#125;)&#125;\\quad\\overleftrightarrow&#123;E(\\vec&#123;r&#125;)&#125;\\quad\\underrightarrow&#123;E(\\vec&#123;r&#125;)&#125;\\quad\\underleftarrow&#123;E(\\vec&#123;r&#125;)&#125;\\quad\\underleftrightarrow&#123;E(\\vec&#123;r&#125;)&#125;\\quad\\overline&#123;v&#125;=\\bar&#123;v&#125;\\quad\\underline&#123;v&#125;$ 效果:$\\overrightarrow{E(\\vec{r})}\\quad\\overleftarrow{E(\\vec{r})}\\quad\\overleftrightarrow{E(\\vec{r})}\\quad\\underrightarrow{E(\\vec{r})}\\quad\\underleftarrow{E(\\vec{r})}\\quad\\underleftrightarrow{E(\\vec{r})}\\quad\\overline{v}&#x3D;\\bar{v}\\quad\\underline{v}$ 8、积分 代码: 123&gt;$$&gt;\\iint\\limits_D\\left(\\dfrac&#123;\\partial Q&#125;&#123;\\partial x&#125;-\\dfrac&#123;\\partial P&#125;&#123;\\partial y&#125;\\right)&#123;\\rm d&#125;x&#123;\\rm d&#125;y=\\oint\\limits_LP&#123;\\rm d&#125;x+Q&#123;\\rm d&#125;y&gt;$$ 效果:$$\\iint\\limits_D\\left(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y}\\right){\\rm d}x{\\rm d}y&#x3D;\\oint\\limits_LP{\\rm d}x+Q{\\rm d}y$$ 9、极限 代码: 1&gt;$\\lim\\limits_&#123;n\\to\\infin&#125;(1+\\dfrac&#123;1&#125;&#123;n&#125;)^n=e$ 效果:$\\lim\\limits_{n\\to\\infin}(1+\\dfrac{1}{n})^n&#x3D;e$ 10、累加、累乘及交集、并集 1&gt;$\\sum\\limits_&#123;i=1&#125;^n\\dfrac&#123;1&#125;&#123;n^2&#125;\\quad and\\quad\\prod\\limits_&#123;i=1&#125;^n\\dfrac&#123;1&#125;&#123;n^2&#125;\\quad and\\quad\\bigcup\\limits_&#123;i=1&#125;^n\\dfrac&#123;1&#125;&#123;n^2&#125;\\quad and\\quad\\bigcap\\limits_&#123;i=1&#125;^n\\dfrac&#123;1&#125;&#123;n^2&#125;$ 效果:$\\sum\\limits_{i&#x3D;1}^n\\dfrac{1}{n^2}\\quad and\\quad\\prod\\limits_{i&#x3D;1}^n\\dfrac{1}{n^2}\\quad and\\quad\\bigcup\\limits_{i&#x3D;1}^n\\dfrac{1}{n^2}\\quad and\\quad\\bigcap\\limits_{i&#x3D;1}^n\\dfrac{1}{n^2}$ 11、希腊字母 语法 字母 语法 字母 语法 字母 \\Alpha(\\alpha) $\\Alpha(\\alpha)$ \\Beta(\\beta) $\\Beta(\\beta)$ \\Gamma(\\gamma) $\\Gamma(\\gamma)$ \\Epsilon(\\epsilon)\\varepsilon $\\Epsilon(\\epsilon)\\varepsilon$ \\Zeta(\\zeta) $\\Zeta(\\zeta)$ \\Eta(\\eta) $\\Eta(\\eta)$ \\Iota(\\iota) $\\Iota(\\iota)$ \\Kappa(\\kappa)\\varkappa $\\Kappa(\\kappa)\\varkappa$ \\Lambda(\\lambda) $\\Lambda(\\lambda)$ \\Nu(\\nu) $\\Nu(\\nu)$ \\Xi(\\xi) $\\Xi(\\xi)$ \\Omicron(\\omicron) $\\Omicron(\\omicron)$ \\Rho(\\rho)\\varrho $\\Rho(\\rho)\\varrho$ \\Sigma(\\sigma)\\varsigma $\\Sigma(\\sigma)\\varsigma$ \\Tau(\\tau) $\\Tau(\\tau)$ \\Phi(\\phi)\\varphi $\\Phi(\\phi)\\varphi$ \\Chi(\\chi) $\\Chi(\\chi)$ \\Psi(\\psi) $\\Psi(\\psi)$ \\Delta(\\delta) $\\Delta(\\delta)$ \\Theta(\\theta)\\vartheta $\\Theta(\\theta)\\vartheta$ \\Mu(\\mu) $\\Mu(\\mu)$ \\Pi(\\pi)\\varpi $\\Pi(\\pi)\\varpi$ \\Omega(\\omega) $\\Omega(\\omega)$ \\upsilon $\\upsilon$ \\ell $\\ell$ \\eth $\\eth$ \\hbar $\\hbar$ \\hslash $\\hslash$ \\mho $\\mho$ \\partial $\\partial$ 12、特殊字符①说明 可以在字符前使用\\large或\\small以显示更大或更小的字符。${\\LARGE A}{\\Large A}{\\large A}A{\\small A}$ ②关系运算符 输入 显示 输入 显示 输入 显示 \\pm(\\mp) $\\pm(\\mp)$ \\times $\\times$ \\div $\\div$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\mid $\\mid$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\ge $\\ge$ \\le $\\le$ \\ll $\\ll$ \\geqslant $\\geqslant$ \\leqslant $\\leqslant$ \\neq $\\neq$ \\approx $\\approx$ \\xlongequal{文本} $\\xlongequal{文本}$ \\triangleq $\\triangleq$ \\sim $\\sim$ \\doteq $\\doteq$ \\equiv $\\equiv$ \\cong $\\cong$ \\propto $\\propto$ \\parallel(\\ ) \\prec $\\prec$ \\pmod{2} $\\pmod{2}$ \\bmod $\\bmod{2}$ ③集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\varnothing $\\varnothing$ \\subset $\\subset$ \\subseteq $\\subseteq$ \\subsetneq $\\subsetneq$ \\supset $\\supset$ \\supseteq $\\supseteq$ \\supsetneq $\\supsetneq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\setminus $\\setminus$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\in $\\in$ \\notin $\\notin$ \\ni $\\ni$ ④三角运算符 输入 显示 输入 显示 输入 显示 \\circ $\\circ$ \\bot $\\bot$ \\angle $\\angle$ \\degree $\\degree$ ⑤微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\oint $\\oint$ \\oiint $\\oiint$ \\prime(‘) $\\prime$ \\lim $\\lim$ \\infin $\\infin$ \\nabla $\\nabla$ \\grad $\\grad$ ⑥逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exist $\\exist$ \\not&gt; $\\not&gt;$ \\not&lt; $\\not&lt;$ \\land $\\land$ \\lor $\\lor$ \\lnot $\\lnot$ \\top $\\top$ \\vdash $\\vdash$ \\vDash $\\vDash$ ⑦带帽符号 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\check{x} $\\check{x}$ \\breve{y} $\\breve{y}$ \\grave{x} $\\grave{x}$ \\acute{y} $\\acute{y}$ \\dot{x} $\\dot{x}$ \\ddot{x} $\\ddot{x}$ \\overparen{xy} $\\overparen{xy}$ ⑧选取符号 输入 显示 输入 显示 \\fbox{a+b+c+d} $\\fbox{a+b+c+d}$ \\overbrace{xx\\cdots x}^{10个x} $\\overbrace{xx\\cdots x}^{10个x}$ \\underbrace{xx\\cdots x}_{10个x} $\\underbrace{xx\\cdots x}_{10个x}$ ⑨箭头符号 输入 显示 输入 显示 输入 显示 \\leftarrow $\\leftarrow$ \\rightarrow $\\rightarrow$ \\leftrightarrow $\\leftrightarrow$ \\longleftarrow $\\longleftarrow$ \\longrightarrow $\\longrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Leftarrow $\\Leftarrow$ \\Rightarrow $\\Rightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\Longleftarrow $\\Longleftarrow$ \\Longrightarrow $\\Longrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\updownarrow $\\updownarrow$ \\Uparrow $\\Uparrow$ \\Downarrow $\\Downarrow$ \\Updownarrow $\\Updownarrow$ \\to $\\to$ \\swarrow $\\swarrow$ \\nearrow $\\nearrow$ \\gets $\\gets$ \\searrow $\\searrow$ \\nwarrow $\\nwarrow$ \\mapsto $\\mapsto$ \\rightrightarrows $\\rightrightarrows$ ⑩空格 输入 效果 输入 效果 输入 效果 \\! $ ! $ 默认 $ , $ , $ ;(\\ ) $ 13、字体 代码: 1$&#123;\\字体&#123;需要转换的字符&#125;&#125;$ 输入 说明 显示 输入 说明 显示 \\rm 罗马体 ${\\rm{Sample}}$ \\cal 花体 ${\\cal{Sample}}$ \\it 意大利体 ${\\it{Sample}}$ \\Bbb 黑板粗体 ${\\Bbb{Sample}}$ \\bf 粗体 ${\\bf{Sample}}$ \\mit 数学斜体 ${\\mit{Sample}}$ \\sf 等线体 ${\\sf{Sample}}$ \\scr 手写体 ${\\scr{Sample}}$ \\tt 打字机体 ${\\tt{Sample}}$ \\frak 旧德式字体 ${\\frak{Sample}}$ 14、大括号和行标 说明: 使用\\left和\\right来创建自动匹配高度的()、[]、&#123;&#125;、.。在每个公式末尾使用\\tag&#123;行标&#125;来实现行标。 代码: 123456789&gt;$$&gt;f\\left(&gt;\\left[&gt;\\dfrac&#123;1+\\&#123;x,y\\&#125;&#125;&#123;\\left(\\dfrac&#123;x&#125;&#123;y&#125;+\\dfrac&#123;y&#125;&#123;x&#125;\\right)(u+1)&#125;+a&gt;\\right]&gt;^&#123;\\dfrac&#123;3&#125;&#123;2&#125;&#125;&gt;\\right)&gt;\\tag&#123;行标&#125;&gt;$$ 效果:$$f\\left(\\left[\\dfrac{1+{x,y}}{\\left(\\dfrac{x}{y}+\\dfrac{y}{x}\\right)(u+1)}+a\\right]^{\\dfrac{3}{2}}\\right)\\tag{行标}$$ 说明:如果你想将行内显示的分隔符也变大,也可以使用\\middle命令 代码: 123&gt;$$&gt;\\left\\langle q\\middle\\|\\dfrac&#123;\\dfrac&#123;x&#125;&#123;y&#125;&#125;&#123;\\dfrac&#123;u&#125;&#123;v&#125;&#125;\\middle|p\\right\\rangle&gt;$$ 效果:$$\\left\\langle q\\middle|\\dfrac{\\dfrac{x}{y}}{\\dfrac{u}{v}}\\middle|p\\right\\rangle$$ 15、其他命令①注释文字 代码: 1&gt;$\\text&#123;文字&#125;$ 效果:$$f(n)&#x3D;\\begin{cases}n&#x2F;2,&amp;\\text{if $n$ is even}\\3n+1,&amp;\\text{if $n$ is odd}\\end{cases}$$ ③文字颜色 适用新旧浏览器代码:1$\\color&#123;颜色&#125;&#123;文字&#125;$ 输入 显示 输入 显示 输入 显示 black $\\color{black}{color}$ grey $\\color{grey}{color}$ silver $\\color{silver}{color}$ white $\\color{white}{color}$ maroon $\\color{maroon}{color}$ red $\\color{red}{color}$ yellow $\\color{yellow}{color}$ lime $\\color{lime}{color}$ olive $\\color{olive}{color}$ green $\\color{green}{color}$ teal $\\color{teal}{color}$ auqa $\\color{auqa}{color}$ blue $\\color{blue}{color}$ navy $\\color{navy}{color}$ purple $\\color{purple}{color}$ fuchsia $\\color{fuchsia}{color}$ 适用新版浏览器代码:1&gt;$\\color&#123;#rgb&#125;&#123;文字&#125;$ (注:其中r、g、b可以输入0~9和a~f来分别表示红色、绿色和蓝色的纯度) 输入 输出 输入 输出 输入 输出 输入 输出 #000 $\\color","categories":[{"name":"Typora","slug":"Typora","permalink":"https://www.tangyongao.top/categories/Typora/"}],"tags":[{"name":"Typora使用","slug":"Typora使用","permalink":"https://www.tangyongao.top/tags/Typora%E4%BD%BF%E7%94%A8/"}],"author":["Internet"]},{"title":"Spring","slug":"Spring","date":"2023-03-03T05:51:37.085Z","updated":"2023-03-03T06:42:10.201Z","comments":true,"path":"2023/03/03/Spring/","link":"","permalink":"https://www.tangyongao.top/2023/03/03/Spring/","excerpt":"","text":"Spring_day01今日目标 掌握Spring相关概念 完成IOC&#x2F;DI的入门案例编写 掌握IOC的相关配置与使用 掌握DI的相关配置与使用 1，课程介绍对于一门新技术，我们需要从为什么要学、学什么以及怎么学这三个方向入手来学习。那对于Spring来说: 1.1 为什么要学? 从使用和占有率看 Spring在市场的占有率与使用率高 Spring在企业的技术选型命中率高 所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;&#x3D;&#x3D;90%&#x3D;&#x3D; 说明:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。 从专业角度看 随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决? Spring可以&#x3D;&#x3D;简化开发&#x3D;&#x3D;，降低企业级开发的复杂性，使开发变得更简单快捷 随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作? Spring可以&#x3D;&#x3D;框架整合&#x3D;&#x3D;，高效整合其他技术，提高企业级应用开发与运行效率 综上所述，&#x3D;&#x3D;Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。&#x3D;&#x3D; 1.2 学什么?从上面的介绍中，我们可以看到Spring框架主要的优势是在简化开发和框架整合上，至于如何实现就是咱们要学习Spring框架的主要内容: 简化开发: Spring框架中提供了两个大的核心技术，分别是: &#x3D;&#x3D;IOC&#x3D;&#x3D; &#x3D;&#x3D;AOP&#x3D;&#x3D; &#x3D;&#x3D;事务处理&#x3D;&#x3D; 1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。 2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。 框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如: &#x3D;&#x3D;MyBatis&#x3D;&#x3D; MyBatis-plus Struts Struts2 Hibernate …… 这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。 综上所述，对于Spring的学习，主要学习四块内容: &#x3D;&#x3D;(1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用)&#x3D;&#x3D; 1.3 怎么学? 学习Spring框架设计思想 对于Spring来说，它能迅速占领全球市场，不只是说它的某个功能比较强大，更重要是在它的思想上。 学习基础操作，思考操作与思想间的联系 掌握了Spring的设计思想，然后就需要通过一些基础操作来思考操作与思想之间的关联关系 学习案例，熟练应用操作的同时，体会思想 会了基础操作后，就需要通过大量案例来熟练掌握框架的具体应用，加深对设计思想的理解。 介绍完为什么要学、学什么和怎么学Spring框架后，大家需要重点掌握的是: Spring很优秀，需要认真重点的学习 Spring的学习主线是IOC、AOP、声明式事务和整合MyBais 接下来，咱们就开始进入Spring框架的学习。 2，Spring相关概念2.1 初识Spring在这一节，主要通过以下两个点来了解下Spring: 2.1.1 Spring家族 官网：https://spring.io，从官网我们可以大概了解到： Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。 Spring并不是单一的一个技术，而是一个大家族，可以从官网的Projects中查看其包含的所有技术。 Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。 Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。 Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫&#x3D;&#x3D;全家桶&#x3D;&#x3D;，如下图 说明: 图中的图标都代表什么含义，可以进入https://spring.io/projects网站进行对比查看。 这些技术并不是所有的都需要学习，额外需要重点关注Spring Framework、SpringBoot和SpringCloud: Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。 SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。 SpringCloud:这个是用来做分布式之微服务架构的相关开发。 除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是&#x3D;&#x3D;Spring Framework&#x3D;&#x3D;。 2.1.2 了解Spring发展史 接下来我们介绍下Spring Framework这个技术是如何来的呢? Spring发展史 IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。 Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的Expert One-on-One J2EE Design and Development,书中有阐述在开发中使用EJB该如何做。 Rod Johnson在2004年出版的Expert One-on-One J2EE Development without EJB,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。 随着时间推移，版本不断更新维护，目前最新的是Spring5 Spring1.0是纯配置文件开发 Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式 Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主 Spring4.0根据JDK的版本升级对个别API进行了调整 Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版 本节介绍了Spring家族与Spring的发展史，需要大家重点掌握的是: 今天所学的Spring其实是Spring家族中的Spring Framework Spring Framework是Spring家族中其他框架的底层基础，学好Spring可以为其他Spring框架的学习打好基础 2.2 Spring系统架构前面我们说spring指的是Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架? 针对这些问题，我们将从系统架构图和课程学习路线来进行说明: 2.2.1 系统架构图 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。 Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整 Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图 (1)核心层 Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块 (2)AOP层 AOP:面向切面编程，它依赖核心层容器，目的是&#x3D;&#x3D;在不改变原有代码的前提下对其进行功能增强&#x3D;&#x3D; Aspects:AOP是思想,Aspects是对AOP思想的具体实现 (3)数据层 Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术 Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容 (4)Web层 这一层的内容将在SpringMVC框架具体学习 (5)Test层 Spring主要整合了Junit来完成单元测试和集成测试 2.2.2 课程学习路线介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是: &#x3D;&#x3D;Spring的IOC&#x2F;DI&#x3D;&#x3D; &#x3D;&#x3D;Spring的AOP&#x3D;&#x3D; &#x3D;&#x3D;AOP的具体应用,事务管理&#x3D;&#x3D; &#x3D;&#x3D;IOC&#x2F;DI的具体应用,整合Mybatis&#x3D;&#x3D; 对于这节的内容，大家重点要记住的是Spring需要学习的四部分内容。接下来就从第一部分开始学起。 2.3 Spring核心概念在Spring核心概念这部分内容中主要包含IOC/DI、IOC容器和Bean,那么问题就来了，这些都是什么呢? 2.3.1 目前项目中的问题要想解答这个问题，就需要先分析下目前咱们代码在编写过程中遇到的问题: (1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象 (2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署 (3)所以，现在代码在编写的过程中存在的问题是：&#x3D;&#x3D;耦合度偏高&#x3D;&#x3D; 针对这个问题，该如何解决呢? 我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么? 答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。 所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢? 针对这个问题，Spring就提出了一个解决方案: 使用对象时，在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象 这种实现思就是Spring的一个核心概念 2.3.2 IOC、IOC容器、Bean、DI &#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D; (1)什么是控制反转呢？ 使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。 业务层要用数据层的类对象，以前是自己new的 现在自己不new了，交给别人[外部]来创建对象 别人[外部]就反转控制了数据层对象的创建权 这种思想就是控制反转 别人[外部]指定是什么呢?继续往下学 (2)Spring和IOC之间的关系是什么呢? Spring技术对IOC思想进行了实现 Spring提供了一个容器，称为&#x3D;&#x3D;IOC容器&#x3D;&#x3D;，用来充当IOC思想中的”外部” IOC思想中的别人[外部]指的就是Spring的IOC容器 (3)IOC容器的作用以及内部存放的是什么? IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象 被创建或被管理的对象在IOC容器中统称为&#x3D;&#x3D;Bean&#x3D;&#x3D; IOC容器中放的就是一个个的Bean对象 (4)当IOC容器中创建好service和dao对象后，程序能正确执行么? 不行，因为service运行需要依赖dao对象 IOC容器中虽然有service和dao对象 但是service对象和dao对象没有任何关系 需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系 像这种在容器中建立对象与对象之间的绑定关系就要用到DI: &#x3D;&#x3D;DI（Dependency Injection）依赖注入&#x3D;&#x3D; (1)什么是依赖注入呢? 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 业务层要用数据层的类对象，以前是自己new的 现在自己不new了，靠别人[外部其实指的就是IOC容器]来给注入进来 这种思想就是依赖注入 (2)IOC容器中哪些bean之间要建立依赖关系呢? 这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系 介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:&#x3D;&#x3D;充分解耦&#x3D;&#x3D;，具体实现靠: 使用IOC容器管理bean（IOC) 在IOC容器内将有依赖关系的bean进行关系绑定（DI） 最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系. 2.3.3 核心概念小结这节比较重要，重点要理解什么是IOC/DI思想、什么是IOC容器和什么是Bean： (1)什么IOC&#x2F;DI思想? IOC:控制反转，控制反转的是对象的创建权 DI:依赖注入，绑定对象与对象之间的依赖关系 (2)什么是IOC容器? Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器 (3)什么是Bean? 容器中所存放的一个个对象就叫Bean或Bean对象 3，入门案例介绍完Spring的核心概念后，接下来我们得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程: 3.1 IOC入门案例对于入门案例，我们得先分析思路然后再代码实现， 3.1.1 入门案例思路分析(1)Spring是使用容器来管理bean对象的，那么管什么? 主要管理项目中所使用到的类对象，比如(Service和Dao) (2)如何将被管理的对象告知IOC容器? 使用配置文件 (3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器? Spring框架提供相应的接口 (4)IOC容器得到后，如何从容器中获取bean? 调用Spring框架提供对应接口中的方法 (5)使用Spring导入哪些坐标? 用别人的东西，就需要在pom.xml添加对应的依赖 3.1.2 入门案例代码实现 需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。 1.创建Maven的java项目 2.pom.xml添加Spring的依赖jar包 3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类 4.resources下添加spring配置文件，并完成bean的配置 5.使用Spring提供的接口完成IOC容器的创建 6.从容器中获取对象进行方法调用 步骤1:创建Maven项目 步骤2:添加Spring的依赖jar包pom.xml 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 步骤3:添加案例中需要的类创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类 123456789101112131415161718public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125;public interface BookService &#123; public void save();&#125;public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl(); public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; 步骤4:添加spring配置文件resources下添加spring配置文件applicationContext.xml，并完成bean的配置 步骤5:在配置文件中完成bean的配置12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean标签标示配置bean id属性标示给bean起名字 class属性表示给bean定义类型 --&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;/&gt;&lt;/beans&gt; &#x3D;&#x3D;注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复&#x3D;&#x3D; 步骤6:获取IOC容器使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法 123456public class App &#123; public static void main(String[] args) &#123; //获取IOC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); &#125;&#125; 步骤7:从容器中获取对象进行方法调用12345678910public class App &#123; public static void main(String[] args) &#123; //获取IOC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);// bookDao.save(); BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 步骤8:运行程序测试结果为： Spring的IOC入门案例已经完成，但是在BookServiceImpl的类中依然存在BookDaoImpl对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的DI:依赖注入。 3.2 DI入门案例对于DI的入门案例，我们依然先分析思路然后再代码实现， 3.2.1 入门案例思路分析(1)要想实现依赖注入，必须要基于IOC管理Bean DI的入门案例要依赖于前面IOC的入门案例 (2)Service中使用new形式创建的Dao对象是否保留? 需要删除掉，最终要使用IOC容器中的bean对象 (3)Service中需要的Dao对象如何进入到Service中? 在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象 (4)Service与Dao间的关系如何描述? 使用配置文件 3.2.2 入门案例代码实现 需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入 1.删除业务层中使用new的方式创建的dao对象 2.在业务层提供BookDao的setter方法 3.在配置文件中添加依赖注入的配置 4.运行程序调用方法 步骤1: 去除代码中的new在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象 123456789public class BookServiceImpl implements BookService &#123; //删除业务层中使用new的方式创建的dao对象 private BookDao bookDao; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; 步骤2:为属性提供setter方法在BookServiceImpl类中,为BookDao提供setter方法 1234567891011121314public class BookServiceImpl implements BookService &#123; //删除业务层中使用new的方式创建的dao对象 private BookDao bookDao; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125; //提供对应的set方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 步骤3:修改配置完成注入在配置文件中添加依赖注入的配置 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean标签标示配置bean id属性标示给bean起名字 class属性表示给bean定义类型 --&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;!--配置server与dao的关系--&gt; &lt;!--property标签表示配置当前bean的属性 name属性表示配置哪一个具体的属性 ref属性表示参照哪一个bean --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; &#x3D;&#x3D;注意:配置中的两个bookDao的含义是不一样的&#x3D;&#x3D; name&#x3D;”bookDao”中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入 ref&#x3D;”bookDao”中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入 综上所述，对应关系如下: 步骤4:运行程序运行，测试结果为： 4，IOC相关内容通过前面两个案例，我们已经学习了bean如何定义配置，DI如何定义配置以及容器对象如何获取的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。 4.1 bean基础配置对于bean的配置中，主要会讲解bean基础配置,bean的别名配置,bean的作用范围配置&#x3D;&#x3D;(重点)&#x3D;&#x3D;,这三部分内容： 4.1.1 bean基础配置(id与class)对于bean的基础配置，在前面的案例中已经使用过: 1&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; 其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下 这其中需要大家重点掌握的是:&#x3D;&#x3D;bean标签的id和class属性的使用&#x3D;&#x3D;。 思考： class属性能不能写接口如BookDao的类全名呢? 答案肯定是不行，因为接口是没办法创建对象的。 前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决? 在解决这个问题之前，我们需要准备下开发环境，对于开发环境我们可以有两种解决方案: 使用前面IOC和DI的案例 重新搭建一个新的案例环境,目的是方便大家查阅代码 搭建的内容和前面的案例是一样的，内容如下： 4.1.2 bean的name属性环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置， 首先来看下别名的配置说明: 步骤1：配置别名打开spring的配置文件applicationContext.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt; &lt;bean id=&quot;bookService&quot; name=&quot;service service4 bookEbi&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt; &lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt; &lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;&lt;/beans&gt; 说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口 步骤2:根据名称容器中获取bean对象12345678public class AppForName &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //此处根据bean标签的id属性和name属性的任意一个值来获取bean对象 BookService bookService = (BookService) ctx.getBean(&quot;service4&quot;); bookService.save(); &#125;&#125; 步骤3:运行程序测试结果为： &#x3D;&#x3D;注意事项:&#x3D;&#x3D; bean依赖注入的ref属性指定bean，必须在容器中存在 如果不存在,则会报错，如下: 这个错误大家需要特别关注下: 获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D; 4.1.3 bean作用范围scope配置关于bean的作用范围是bean属性配置的一个&#x3D;&#x3D;重点&#x3D;&#x3D;内容。 看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的? 我们先来看下bean作用范围的配置属性: 4.1.3.1 验证IOC容器中对象是否为单例验证思路​ 同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。 具体实现 创建一个AppForScope的类，在其main方法中来验证 1234567891011public class AppForScope &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao1 = (BookDao) ctx.getBean(&quot;bookDao&quot;); BookDao bookDao2 = (BookDao) ctx.getBean(&quot;bookDao&quot;); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 打印，观察控制台的打印结果 结论:默认情况下，Spring创建的bean对象都是单例的 获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢? 4.1.3.2 配置bean为非单例在Spring配置文件中，配置scope属性来实现bean的非单例创建 在Spring的配置文件中，修改&lt;bean&gt;的scope属性 1&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;&quot;/&gt; 将scope设置为singleton 1&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;singleton&quot;/&gt; 运行AppForScope，打印看结果 将scope设置为prototype 1&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt; 运行AppForScope，打印看结果 结论，使用bean的scope属性可以控制bean的创建是否为单例： singleton默认为单例 prototype为非单例 4.1.3.3 scope使用后续思考介绍完scope属性以后，我们来思考几个问题: 为什么bean默认为单例? bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象 bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高 bean在容器中是单例的，会不会产生线程安全问题? 如果对象是有状态对象，即该对象有成员变量可以用来存储数据的， 因为所有请求线程共用一个bean对象，所以会存在线程安全问题。 如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的， 因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。 哪些bean对象适合交给容器进行管理? 表现层对象 业务层对象 数据层对象 工具对象 哪些bean对象不适合交给容器进行管理? 封装实例的域对象，因为会引发线程安全问题，所以不适合。 4.14 bean基础配置小结关于bean的基础配置中，需要大家掌握以下属性: 4.2 bean实例化对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢? 就需要研究下bean的实例化过程，在这块内容中主要解决两部分内容，分别是 bean是如何创建的 实例化bean的三种方式，构造方法,静态工厂和实例工厂 在讲解这三种创建方式之前，我们需要先确认一件事: bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。 基于这个知识点出发，我们来验证spring中bean的三种创建方式， 4.2.1 环境准备为了方便大家阅读代码，重新准备个开发环境， 创建一个Maven项目 pom.xml添加依赖 resources下添加spring的配置文件applicationContext.xml 这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下: 4.2.2 构造方法实例化在上述的环境下，我们来研究下Spring中的第一种bean的创建方式构造方法实例化: 步骤1:准备需要被创建的类准备一个BookDao和BookDaoImpl类 1234567891011public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125; 步骤2:将类配置到Spring容器12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;&lt;/beans&gt; 步骤3:编写运行程序123456789public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 步骤4:类中提供构造函数测试在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。 123456789public class BookDaoImpl implements BookDao &#123; public BookDaoImpl() &#123; System.out.println(&quot;book dao constructor is running ....&quot;); &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125; 运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数 步骤5:将构造函数改成private测试123456789public class BookDaoImpl implements BookDao &#123; private BookDaoImpl() &#123; System.out.println(&quot;book dao constructor is running ....&quot;); &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125; 运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反 步骤6:构造函数中添加一个参数测试123456789public class BookDaoImpl implements BookDao &#123; private BookDaoImpl(int i) &#123; System.out.println(&quot;book dao constructor is running ....&quot;); &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125; 运行程序， 程序会报错，说明Spring底层使用的是类的无参构造方法。 4.2.3 分析Spring的错误信息接下来，我们主要研究下Spring的报错信息来学一学如阅读。 错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面 Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.&lt;init&gt;() Caused by 翻译为引起，即出现错误的原因 java.lang.NoSuchMethodException:抛出的异常为没有这样的方法异常 com.itheima.dao.impl.BookDaoImpl.&lt;init&gt;():哪个类的哪个方法没有被找到导致的异常，&lt;init&gt;()指定是类的构造方法，即该类的无参构造方法 如果最后一行错误获取不到错误信息，接下来查看第二层: Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.&lt;init&gt;() nested:嵌套的意思，后面的异常内容和最底层的异常是一致的 Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; Caused by: 引发 BeanInstantiationException:翻译为bean实例化异常 No default constructor found:没有一个默认的构造函数被发现 看到这其实错误已经比较明显，给大家个练习，把倒数第三层的错误分析下吧: Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘bookDao’ defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.&lt;init&gt;()。 至此，关于Spring的构造方法实例化就已经学习完了，因为每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做。这也是我们以后比较常用的一种方式。 4.2.4 静态工厂实例化接下来研究Spring中的第二种bean的创建方式静态工厂实例化: 4.2.4.1 工厂方式创建bean在讲这种方式之前，我们需要先回顾一个知识点是使用工厂来创建对象的方式: (1)准备一个OrderDao和OrderDaoImpl类 123456789public interface OrderDao &#123; public void save();&#125;public class OrderDaoImpl implements OrderDao &#123; public void save() &#123; System.out.println(&quot;order dao save ...&quot;); &#125;&#125; (2)创建一个工厂类OrderDaoFactory并提供一个&#x3D;&#x3D;静态方法&#x3D;&#x3D; 123456//静态工厂创建对象public class OrderDaoFactory &#123; public static OrderDao getOrderDao()&#123; return new OrderDaoImpl(); &#125;&#125; (3)编写AppForInstanceOrder运行类，在类中通过工厂获取对象 1234567public class AppForInstanceOrder &#123; public static void main(String[] args) &#123; //通过静态工厂创建对象 OrderDao orderDao = OrderDaoFactory.getOrderDao(); orderDao.save(); &#125;&#125; (4)运行后，可以查看到结果 如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢? 4.2.4.2 静态工厂实例化这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为: (1)在spring的配置文件application.properties中添加以下内容: 1&lt;bean id=&quot;orderDao&quot; class=&quot;com.itheima.factory.OrderDaoFactory&quot; factory-method=&quot;getOrderDao&quot;/&gt; class:工厂类的类全名 factory-mehod:具体工厂类中创建对象的方法名 (2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试 12345678910public class AppForInstanceOrder &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); OrderDao orderDao = (OrderDao) ctx.getBean(&quot;orderDao&quot;); orderDao.save(); &#125;&#125; (3)运行后，可以查看到结果 看到这，可能有人会问了，你这种方式在工厂类中不也是直接new对象的，和我自己直接new没什么太大的区别，而且静态工厂的方式反而更复杂，这种方式的意义是什么? 主要的原因是: 在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少,如: 123456public class OrderDaoFactory &#123; public static OrderDao getOrderDao()&#123; System.out.println(&quot;factory setup....&quot;);//模拟必要的业务操作 return new OrderDaoImpl(); &#125;&#125; 之前new对象的方式就无法添加其他的业务内容，重新运行，查看结果: 介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以&#x3D;&#x3D;了解为主&#x3D;&#x3D;。 4.2.5 实例工厂与FactoryBean接下来继续来研究Spring的第三种bean的创建方式实例工厂实例化: 4.2.3.1 环境准备(1)准备一个UserDao和UserDaoImpl类 12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;user dao save ...&quot;); &#125;&#125; (2)创建一个工厂类OrderDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法 12345public class UserDaoFactory &#123; public UserDao getUserDao()&#123; return new UserDaoImpl(); &#125;&#125; (3)编写AppForInstanceUser运行类，在类中通过工厂获取对象 12345678public class AppForInstanceUser &#123; public static void main(String[] args) &#123; //创建实例工厂对象 UserDaoFactory userDaoFactory = new UserDaoFactory(); //通过实例工厂对象创建对象 UserDao userDao = userDaoFactory.getUserDao(); userDao.save();&#125; (4)运行后，可以查看到结果 对于上面这种实例工厂的方式如何交给Spring管理呢? 4.2.3.2 实例工厂实例化具体实现步骤为: (1)在spring的配置文件中添加以下内容: 12&lt;bean id=&quot;userFactory&quot; class=&quot;com.itheima.factory.UserDaoFactory&quot;/&gt;&lt;bean id=&quot;userDao&quot; factory-method=&quot;getUserDao&quot; factory-bean=&quot;userFactory&quot;/&gt; 实例化工厂运行的顺序是: 创建实例化工厂对象,对应的是第一行配置 调用对象中的方法来创建bean，对应的是第二行配置 factory-bean:工厂的实例对象 factory-method:工厂对象中的具体创建对象的方法名,对应关系如下: factory-mehod:具体工厂类中创建对象的方法名 (2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试 12345678public class AppForInstanceUser &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; (3)运行后，可以查看到结果 实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫FactoryBean的方式来简化开发。 4.2.3.3 FactoryBean的使用具体的使用步骤为: (1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法 12345678910public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; &#123; //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception &#123; return new UserDaoImpl(); &#125; //返回所创建类的Class对象 public Class&lt;?&gt; getObjectType() &#123; return UserDao.class; &#125;&#125; (2)在Spring的配置文件中进行配置 1&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean&quot;/&gt; (3)AppForInstanceUser运行类不用做任何修改，直接运行 这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要大家理解掌握。 查看源码会发现，FactoryBean接口其实会有三个方法，分别是: 1234567T getObject() throws Exception;Class&lt;?&gt; getObjectType();default boolean isSingleton() &#123; return true;&#125; 方法一:getObject()，被重写后，在方法中进行对象的创建并返回 方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象 方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢? 思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。 12345678910public class AppForInstanceUser &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao1 = (UserDao) ctx.getBean(&quot;userDao&quot;); UserDao userDao2 = (UserDao) ctx.getBean(&quot;userDao&quot;); System.out.println(userDao1); System.out.println(userDao2); &#125;&#125; 打印结果，如下: 通过验证，会发现默认是单例，那如果想改成单例具体如何实现? 只需要将isSingleton()方法进行重写，修改返回为false，即可 123456789101112131415//FactoryBean创建对象public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; &#123; //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception &#123; return new UserDaoImpl(); &#125; public Class&lt;?&gt; getObjectType() &#123; return UserDao.class; &#125; public boolean isSingleton() &#123; return false; &#125;&#125; 重新运行AppForInstanceUser，查看结果 从结果中可以看出现在已经是非单例了，但是一般情况下我们都会采用单例，也就是采用默认即可。所以isSingleton()方法一般不需要进行重写。 4.2.6 bean实例化小结通过这一节的学习，需要掌握: (1)bean是如何创建的呢? 1构造方法 (2)Spring的IOC实例化对象的三种方式分别是: 构造方法(常用) 静态工厂(了解) 实例工厂(了解) FactoryBean(实用) 这些方式中，重点掌握构造方法和FactoryBean即可。 需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。 4.3 bean的生命周期关于bean的相关知识还有最后一个是bean的生命周期,对于生命周期，我们主要围绕着bean生命周期控制来讲解: 首先理解下什么是生命周期? 从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。 bean生命周期是什么? bean对象从创建到销毁的整体过程。 bean生命周期控制是什么? 在bean创建后到销毁前做一些事情。 现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。 4.3.1 环境准备还是老规矩，为了方便大家后期代码的阅读，我们重新搭建下环境: 创建一个Maven项目 pom.xml添加依赖 resources下添加spring的配置文件applicationContext.xml 这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下: (1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类 1234567891011121314151617181920212223242526public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125;public interface BookService &#123; public void save();&#125;public class BookServiceImpl implements BookService&#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; (2)resources下提供spring的配置文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;&lt;/beans&gt; (3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象 12345678public class AppForLifeCycle &#123; public static void main( String[] args ) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 4.3.2 生命周期设置接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段: bean创建之后，想要添加内容，比如用来初始化需要用到资源 bean销毁之前，想要添加内容，比如用来释放用到的资源 步骤1:添加初始化和销毁方法针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，&#x3D;&#x3D;方法名任意&#x3D;&#x3D; 12345678910111213public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125; //表示bean初始化对应的操作 public void init()&#123; System.out.println(&quot;init...&quot;); &#125; //表示bean销毁前对应的操作 public void destory()&#123; System.out.println(&quot;destory...&quot;); &#125;&#125; 步骤2:配置生命周期在配置文件添加配置，如下: 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt; 步骤3:运行程序运行AppForLifeCycle打印结果为: 从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢? Spring的IOC容器是运行在JVM中 运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行 main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了 所以没有调用对应的destroy方法 知道了出现问题的原因，具体该如何解决呢? 4.3.3 close关闭容器 ApplicationContext中没有close方法 需要将ApplicationContext更换成ClassPathXmlApplicationContext 12ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 调用ctx的close()方法 1ctx.close(); 运行程序，就能执行destroy方法的内容 4.3.4 注册钩子关闭容器 在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器 调用ctx的registerShutdownHook()方法 1ctx.registerShutdownHook(); **注意:**registerShutdownHook在ApplicationContext中也没有 运行后，查询打印结果 两种方式介绍完后，close和registerShutdownHook选哪个? 相同点:这两种都能用来关闭容器 不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。 分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。 Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置init-method和destroy-method 接下来在BookServiceImpl完成这两个接口的使用: 修改BookServiceImpl类，添加两个接口InitializingBean， DisposableBean并实现接口中的两个方法afterPropertiesSet和destroy 12345678910111213141516public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125; public void destroy() throws Exception &#123; System.out.println(&quot;service destroy&quot;); &#125; public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init&quot;); &#125;&#125; 重新运行AppForLifeCycle类， 那第二种方式的实现，我们也介绍完了。 小细节 对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为属性设置之后。 对于BookServiceImpl来说，bookDao是它的一个属性 setBookDao方法是Spring的IOC容器为其注入属性的方法 思考:afterPropertiesSet和setBookDao谁先执行? 从方法名分析，猜想应该是setBookDao方法先执行 验证思路，在setBookDao方法中添加一句话 12345public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;set .....&quot;); this.bookDao = bookDao; &#125; 重新运行AppForLifeCycle，打印结果如下: 验证的结果和我们猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。 4.3.5 bean生命周期小结(1)关于Spring中对bean生命周期控制提供了两种方式: 在配置文件中的bean标签中添加init-method和destroy-method属性 类实现InitializingBean与DisposableBean接口，这种方式了解下即可。 (2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下: 初始化容器 1.创建对象(内存分配) 2.执行构造方法 3.执行属性注入(set操作) &#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D; 使用bean 1.执行业务操作 关闭&#x2F;销毁容器 &#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D; (3)关闭容器的两种方式: ConfigurableApplicationContext是ApplicationContext的子类 close()方法 registerShutdownHook()方法 5，DI相关内容前面我们已经完成了bean相关操作的讲解，接下来就进入第二个大的模块DI依赖注入，首先来介绍下Spring中有哪些注入方式? 我们先来思考 向一个类中传递数据的方式有几种? 普通方法(set方法) 构造方法 依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢? 引用类型 简单类型(基本数据类型与String) Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是: setter注入 简单类型 &#x3D;&#x3D;引用类型&#x3D;&#x3D; 构造器注入 简单类型 引用类型 依赖注入的方式已经介绍完，接下来挨个学习下: 5.1 setter注入 对于setter方式注入引用类型的方式之前已经学习过，快速回顾下: 在bean中定义引用类型属性，并提供可访问的&#x3D;&#x3D;set&#x3D;&#x3D;方法 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 配置中使用&#x3D;&#x3D;property&#x3D;&#x3D;标签&#x3D;&#x3D;ref&#x3D;&#x3D;属性注入引用类型对象 12345&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.imipl.BookDaoImpl&quot;/&gt; 5.1.1 环境准备为了更好的学习下面内容，我们依旧准备一个新环境: 创建一个Maven项目 pom.xml添加依赖 resources下添加spring的配置文件 这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下: (1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类 12345678910111213141516171819202122232425262728293031323334public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125;public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;user dao save ...&quot;); &#125;&#125;public interface BookService &#123; public void save();&#125;public class BookServiceImpl implements BookService&#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; (2)resources下提供spring的配置文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; (3)编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象 1234567public class AppForDISet &#123; public static void main( String[] args ) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 接下来，在上面这个环境中来完成setter注入的学习: 5.1.2 注入引用数据类型 需求:在bookServiceImpl对象中注入userDao 1.在BookServiceImpl中声明userDao属性 2.为userDao属性提供setter方法 3.在配置文件中使用property标签注入 步骤1:声明属性并提供setter方法在BookServiceImpl中声明userDao属性，并提供setter方法 1234567891011121314151617public class BookServiceImpl implements BookService&#123; private BookDao bookDao; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); userDao.save(); &#125;&#125; 步骤2:配置文件中进行注入配置在applicationContext.xml配置文件中使用property标签注入 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 步骤3:运行程序运行AppForDISet类，查看结果，说明userDao已经成功注入。 5.1.3 注入简单数据类型 需求：给BookDaoImpl注入一些简单数据类型的数据 参考引用数据类型的注入，我们可以推出具体的步骤为: 1.在BookDaoImpl类中声明对应的简单数据类型的属性 2.为这些属性提供对应的setter方法 3.在applicationContext.xml中配置 思考: 引用类型使用的是&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;,简单数据类型还是使用ref么? ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置? 步骤1:声明属性并提供setter方法在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法 1234567891011121314151617public class BookDaoImpl implements BookDao &#123; private String databaseName; private int connectionNum; public void setConnectionNum(int connectionNum) &#123; this.connectionNum = connectionNum; &#125; public void setDatabaseName(String databaseName) &#123; this.databaseName = databaseName; &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot;+databaseName+&quot;,&quot;+connectionNum); &#125;&#125; 步骤2:配置文件中进行注入配置在applicationContext.xml配置文件中使用property标签注入 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;connectionNum&quot; value=&quot;10&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 说明: value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成 1&lt;property name=&quot;connectionNum&quot; value=&quot;abc&quot;/&gt; 这样的话，spring在将abc转换成int类型的时候就会报错。 步骤3:运行程序运行AppForDISet类，查看结果，说明userDao已经成功注入。 **注意:**两个property注入标签的顺序可以任意。 对于setter注入方式的基本使用就已经介绍完了， 对于引用数据类型使用的是&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt; 对于简单数据类型使用的是&lt;property name=&quot;&quot; value=&quot;&quot;/&gt; 5.2 构造器注入5.2.1 环境准备构造器注入也就是构造方法注入，学习之前，还是先准备下环境: 创建一个Maven项目 pom.xml添加依赖 resources下添加spring的配置文件 这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下: (1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类 1234567891011121314151617181920212223242526272829303132333435363738public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; private String databaseName; private int connectionNum; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125;public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println(&quot;user dao save ...&quot;); &#125;&#125;public interface BookService &#123; public void save();&#125;public class BookServiceImpl implements BookService&#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; (2)resources下提供spring的配置文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; (3)编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象 1234567public class AppForDIConstructor &#123; public static void main( String[] args ) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.2.2 构造器注入引用数据类型接下来，在上面这个环境中来完成构造器注入的学习: 需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。 1.将bookDao的setter方法删除掉 2.添加带有bookDao参数的构造方法 3.在applicationContext.xml中配置 步骤1:删除setter方法并提供构造方法在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法 123456789101112public class BookServiceImpl implements BookService&#123; private BookDao bookDao; public BookServiceImpl(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; 步骤2:配置文件中进行配置构造方式注入在applicationContext.xml中配置 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 说明: 标签中 name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。 ref属性指向的是spring的IOC容器中其他bean对象。 步骤3：运行程序运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。 5.2.3 构造器注入多个引用数据类型 需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao 1.声明userDao属性 2.生成一个带有bookDao和userDao参数的构造函数 3.在applicationContext.xml中配置注入 步骤1:提供多个属性的构造函数在BookServiceImpl声明userDao并提供多个参数的构造函数 123456789101112131415public class BookServiceImpl implements BookService&#123; private BookDao bookDao; private UserDao userDao; public BookServiceImpl(BookDao bookDao,UserDao userDao) &#123; this.bookDao = bookDao; this.userDao = userDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); userDao.save(); &#125;&#125; 步骤2:配置文件中配置多参数注入 在applicationContext.xml中配置注入 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; **说明:**这两个&lt;contructor-arg&gt;的配置顺序可以任意 步骤3:运行程序运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。 5.2.4 构造器注入多个简单数据类型 需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。 参考引用数据类型的注入，我们可以推出具体的步骤为: 1.提供一个包含这两个参数的构造方法 2.在applicationContext.xml中进行注入配置 步骤1:添加多个简单属性并提供构造方法修改BookDaoImpl类，添加构造方法 12345678910111213public class BookDaoImpl implements BookDao &#123; private String databaseName; private int connectionNum; public BookDaoImpl(String databaseName, int connectionNum) &#123; this.databaseName = databaseName; this.connectionNum = connectionNum; &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot;+databaseName+&quot;,&quot;+connectionNum); &#125;&#125; 步骤2:配置完成多个属性构造器注入在applicationContext.xml中进行注入配置 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt; &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;666&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; **说明:**这两个&lt;contructor-arg&gt;的配置顺序可以任意 步骤3:运行程序运行AppForDIConstructor类，查看结果 上面已经完成了构造函数注入的基本使用，但是会存在一些问题: 当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变 这两块存在紧耦合，具体该如何解决? 在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。 方式一:删除name属性，添加type属性，按照类型注入 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;10&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;/&gt;&lt;/bean&gt; 这种方式可以解决构造函数形参名发生变化带来的耦合问题 但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了 方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;100&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;/&gt;&lt;/bean&gt; 这种方式可以解决参数类型重复问题 但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题 介绍完两种参数的注入方式，具体我们该如何选择呢? 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 强制依赖指对象在创建的过程中必须要注入指定的参数 可选依赖使用setter注入进行，灵活性强 可选依赖指对象在创建过程中注入的参数可有可无 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 &#x3D;&#x3D;自己开发的模块推荐使用setter注入&#x3D;&#x3D; 这节中主要讲解的是Spring的依赖注入的实现方式: setter注入 简单数据类型 123&lt;bean ...&gt; &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 引用数据类型 123&lt;bean ...&gt; &lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;&lt;/bean&gt; 构造器注入 简单数据类型 123&lt;bean ...&gt; &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 引用数据类型 123&lt;bean ...&gt; &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; ref=&quot;&quot;/&gt;&lt;/bean&gt; 依赖注入的方式选择上 建议使用setter注入 第三方技术根据情况选择 5.3 自动配置前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字&#x3D;&#x3D;麻烦&#x3D;&#x3D;。 问:麻烦在哪? 答:配置文件的编写配置上。 问:有更简单方式么? 答:有，自动配置 什么是自动配置以及如何实现自动配置，就是接下来要学习的内容： 5.3.1 什么是依赖自动装配? IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 5.3.2 自动装配方式有哪些? &#x3D;&#x3D;按类型（常用）&#x3D;&#x3D; 按名称 按构造方法 不启用自动装配 5.3.3 准备下案例环境 创建一个Maven项目 pom.xml添加依赖 resources下添加spring的配置文件 这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下: (1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类 1234567891011121314151617181920212223242526272829public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; private String databaseName; private int connectionNum; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125;public interface BookService &#123; public void save();&#125;public class BookServiceImpl implements BookService&#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; (2)resources下提供spring的配置文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; (3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象 1234567public class AppForAutoware &#123; public static void main( String[] args ) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.3.4 完成自动装配的配置接下来，在上面这个环境中来完成自动装配的学习: 自动装配只需要修改applicationContext.xml配置文件即可: (1)将&lt;property&gt;标签删除 (2)在&lt;bean&gt;标签中添加autowire属性 首先来实现按照类型注入的配置 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;&lt;/beans&gt; &#x3D;&#x3D;注意事项:&#x3D;&#x3D; 需要注入属性的类中对应属性的setter方法不能省略 被注入的对象必须要被Spring的IOC容器管理 按照类型在Spring的IOC容器中如果找到多个对象，会报NoUniqueBeanDefinitionException 一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为: 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; &lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot; autowire=&quot;byName&quot;/&gt;&lt;/beans&gt; &#x3D;&#x3D;注意事项:&#x3D;&#x3D; 按照名称注入中的名称指的是什么? bookDao是private修饰的，外部类无法直接方法 外部类只能通过属性的set方法进行访问 对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名 为什么是去掉set首字母小写? 这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名 所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的 如果按照名称去找对应的bean对象，找不到则注入Null 当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错 两种方式介绍完后，以后用的更多的是&#x3D;&#x3D;按照类型&#x3D;&#x3D;注入。 最后对于依赖注入，需要注意一些其他的配置特征: 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 5.4 集合注入前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型&#x3D;&#x3D;集合&#x3D;&#x3D;，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢? 先来回顾下，常见的集合类型有哪些? 数组 List Set Map Properties 针对不同的集合类型，该如何实现注入呢? 5.4.1 环境准备 创建一个Maven项目 pom.xml添加依赖 resources下添加spring的配置文件applicationContext.xml 这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下: (1)项目中添加添加BookDao、BookDaoImpl类 123456789101112131415161718192021222324252627282930313233public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public class BookDaoImpl implements BookDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; private Properties properties; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array)); System.out.println(&quot;遍历List&quot; + list); System.out.println(&quot;遍历Set&quot; + set); System.out.println(&quot;遍历Map&quot; + map); System.out.println(&quot;遍历Properties&quot; + properties); &#125; //setter....方法省略，自己使用工具生成&#125; (2)resources下提供spring的配置文件，applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;&lt;/beans&gt; (3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象 1234567public class AppForDICollection &#123; public static void main( String[] args ) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 接下来，在上面这个环境中来完成集合注入的学习: 下面的所以配置方式，都是在bookDao的bean标签中使用进行注入 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 5.4.2 注入数组类型数据1234567&lt;property name=&quot;array&quot;&gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 5.4.3 注入List类型数据12345678&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;itcast&lt;/value&gt; &lt;value&gt;itheima&lt;/value&gt; &lt;value&gt;boxuegu&lt;/value&gt; &lt;value&gt;chuanzhihui&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 5.4.4 注入Set类型数据12345678&lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;itcast&lt;/value&gt; &lt;value&gt;itheima&lt;/value&gt; &lt;value&gt;boxuegu&lt;/value&gt; &lt;value&gt;boxuegu&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 5.4.5 注入Map类型数据1234567&lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;country&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;henan&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;kaifeng&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 5.4.6 注入Properties类型数据1234567&lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;country&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;henan&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;kaifeng&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 配置完成后，运行下看结果: 说明： property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写&lt;array&gt;、&lt;list&gt;、&lt;set&gt;、&lt;map&gt;、&lt;props&gt;标签 List的底层也是通过数组实现的，所以&lt;list&gt;和&lt;array&gt;标签是可以混用 集合中要添加引用类型，只需要把&lt;value&gt;标签改成&lt;ref&gt;标签，这种方式用的比较少 Spring_day02今日目标 掌握IOC&#x2F;DI配置管理第三方bean 掌握IOC&#x2F;DI的注解开发 掌握IOC&#x2F;DI注解管理第三方bean 完成Spring与Mybatis及Junit的整合开发 1，IOC&#x2F;DI配置管理第三方bean前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方jar包中的类，该如何管理? 1.1 案例:数据源对象管理在这一节中，我们将通过一个案例来学习下对于第三方bean该如何进行配置管理。 以后我们会用到很多第三方的bean,本次案例将使用咱们前面提到过的数据源Druid(德鲁伊)和C3P0来配置学习下。 1.1.1 环境准备学习之前，先来准备下案例环境: 创建一个Maven项目 pom.xml添加依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resources下添加spring的配置文件applicationContext.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 编写一个运行类App 12345public class App &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); &#125;&#125; 1.1.2 思路分析在上述环境下，我们来对数据源进行配置管理，先来分析下思路: 需求:使用Spring的IOC容器来管理Druid连接池对象 1.使用第三方的技术，需要在pom.xml添加依赖 2.在配置文件中将【第三方的类】制作成一个bean，让IOC容器进行管理 3.数据库连接需要基础的四要素驱动、连接、用户名和密码，【如何注入】到对应的bean中 4.从IOC容器中获取对应的bean对象，将其打印到控制台查看结果 思考: 第三方的类指的是什么? 如何注入数据库连接四要素? 1.1.3 实现Druid管理带着这两个问题，把下面的案例实现下: 步骤1:导入druid的依赖pom.xml中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 步骤2:配置第三方bean在applicationContext.xml配置文件中添加DruidDataSource的配置 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--管理DruidDataSource对象--&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 说明: driverClassName:数据库驱动 url:数据库连接地址 username:数据库连接用户名 password:数据库连接密码 数据库连接的四要素要和自己使用的数据库信息一致。 步骤3:从IOC容器中获取对应的bean对象1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 步骤4:运行程序打印如下结果: 说明第三方bean对象已经被spring的IOC容器进行管理 做完案例后，我们可以将刚才思考的两个问题答案说下: 第三方的类指的是什么? 1DruidDataSource 如何注入数据库连接四要素? 1setter注入 1.1.4 实现C3P0管理完成了DruidDataSource的管理，接下来我们再来加深下练习，这次我们来管理C3P0数据源，具体的实现步骤是什么呢? 需求:使用Spring的IOC容器来管理C3P0连接池对象 实现方案和上面基本一致，重点要关注管理的是哪个bean对象&#96;? 步骤1:导入C3P0的依赖pom.xml中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; 对于新的技术，不知道具体的坐标该如何查找? 直接百度搜索 从mvn的仓库https://mvnrepository.com/中进行搜索 步骤2:配置第三方bean在applicationContext.xml配置文件中添加配置 1234567&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;1000&quot;/&gt;&lt;/bean&gt; &#x3D;&#x3D;注意:&#x3D;&#x3D; ComboPooledDataSource的属性是通过setter方式进行注入 想注入属性就需要在ComboPooledDataSource类或其上层类中有提供属性对应的setter方法 C3P0的四个属性和Druid的四个属性是不一样的 步骤3:运行程序程序会报错，错误如下 报的错为&#x3D;&#x3D;ClassNotFoundException&#x3D;&#x3D;,翻译出来是类没有发现的异常，具体的类为com.mysql.jdbc.Driver。错误的原因是缺少mysql的驱动包。 分析出错误的原因，具体的解决方案就比较简单，只需要在pom.xml把驱动包引入即可。 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 添加完mysql的驱动包以后，再次运行App,就可以打印出结果: 注意： 数据连接池在配置属性的时候，除了可以注入数据库连接四要素外还可以配置很多其他的属性，具体都有哪些属性用到的时候再去查，一般配置基础的四个，其他都有自己的默认值 Druid和C3P0在没有导入mysql驱动包的前提下，一个没报错一个报错，说明Druid在初始化的时候没有去加载驱动，而C3P0刚好相反 Druid程序运行虽然没有报错，但是当调用DruidDataSource的getConnection()方法获取连接的时候，也会报找不到驱动类的错误 1.2 加载properties文件上节中我们已经完成两个数据源druid和C3P0的配置，但是其中包含了一些问题，我们来分析下: 这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护 需要将这些值提取到一个外部的properties配置文件中 Spring框架如何从配置文件中读取属性值来配置就是接下来要解决的问题。 问题提出来后，具体该如何实现? 1.2.1 第三方bean属性优化1.2.1.1 实现思路 需求:将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。 1.在resources下创建一个jdbc.properties(文件的名称可以任意) 2.将数据库连接四要素配置到配置文件中 3.在Spring的配置文件中加载properties文件 4.使用加载到的值实现属性注入 其中第3，4步骤是需要大家重点关注，具体是如何实现。 1.2.1.2 实现步骤步骤1:准备properties配置文件resources下创建一个jdbc.properties文件,并添加对应的属性键值对 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/spring_dbjdbc.username=rootjdbc.password=root 步骤2:开启context命名空间在applicationContext.xml中开context命名空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 步骤3:加载properties配置文件在配置文件中使用context命名空间下的标签来加载properties配置文件 1&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; 步骤4:完成属性注入使用$&#123;key&#125;来读取properties配置文件中的内容并完成属性注入 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 至此，读取外部properties配置文件中的内容就已经完成。 1.2.2 读取单个属性1.2.2.1 实现思路对于上面的案例，效果不是很明显，我们可以换个案例来演示下: 需求:从properties配置文件中读取key为name的值，并将其注入到BookDao中并在save方法中进行打印。 1.在项目中添加BookDao和BookDaoImpl类 2.为BookDaoImpl添加一个name属性并提供setter方法 3.在jdbc.properties中添加数据注入到bookDao中打印方便查询结果 4.在applicationContext.xml添加配置完成配置文件加载、属性注入(${key}) 1.2.2.2 实现步骤步骤1:在项目中添对应的类BookDao和BookDaoImpl类，并在BookDaoImpl类中添加name属性与setter方法 123456789101112131415public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot; + name); &#125;&#125; 步骤2:完成配置文件的读取与注入在applicationContext.xml添加配置，bean的配置管理、读取外部properties、依赖注入: 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 步骤3:运行程序在App类中，从IOC容器中获取bookDao对象，调用方法，查看值是否已经被获取到并打印控制台 12345678public class App &#123; public static void main(String[] args) throws Exception&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1.2.2.3 注意事项至此，读取properties配置文件中的内容就已经完成，但是在使用的时候，有些注意事项: 问题一:键值对的key为username引发的问题 1.在properties中配置键值对的时候，如果key设置为username 1username=root666 2.在applicationContext.xml注入该属性 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3.运行后，在控制台打印的却不是root666，而是自己电脑的用户名 4.出现问题的原因是&lt;context:property-placeholder/&gt;标签会加载系统的环境变量，而且环境变量的值会被优先加载，如何查看系统的环境变量? 1234public static void main(String[] args) throws Exception&#123; Map&lt;String, String&gt; env = System.getenv(); System.out.println(env);&#125; 大家可以自行运行，在打印出来的结果中会有一个USERNAME&#x3D;XXX[自己电脑的用户名称] 5.解决方案 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;&lt;/beans&gt; system-properties-mode:设置为NEVER,表示不加载系统属性，就可以解决上述问题。 当然还有一个解决方案就是避免使用username作为属性的key。 问题二:当有多个properties配置文件需要被加载，该如何配置? 1.调整下配置文件的内容，在resources下添加jdbc.properties,jdbc2.properties,内容如下: jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/spring_dbjdbc.username=rootjdbc.password=root jdbc2.properties 1username=root666 2.修改applicationContext.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--方式一 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties,jdbc2.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;!--方式二--&gt; &lt;context:property-placeholder location=&quot;*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;!--方式三 --&gt; &lt;context:property-placeholder location=&quot;classpath:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;!--方式四--&gt; &lt;context:property-placeholder location=&quot;classpath*:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;&lt;/beans&gt; 说明: 方式一:可以实现，如果配置文件多的话，每个都需要配置 方式二:*.properties代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准 方式三:标准的写法，classpath:代表的是从根路径下开始查找，但是只能查询当前项目的根路径 方式四:不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件 1.2.3 加载properties文件小结 本节主要讲解的是properties配置文件的加载，需要掌握的内容有: 如何开启context命名空间 如何加载properties配置文件 1&lt;context:property-placeholder location=&quot;&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 如何在applicationContext.xml引入properties配置文件中的值 1$&#123;key&#125; 2，核心容器前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的&#x3D;&#x3D;核心容器&#x3D;&#x3D;。 这里所说的核心容器，大家可以把它简单的理解为ApplicationContext，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识: 如何创建容器? 创建好容器后，如何从容器中获取bean对象? 容器类的层次结构是什么? BeanFactory是什么? 2.1 环境准备在学习和解决上述问题之前，先来准备下案例环境: 创建一个Maven项目 pom.xml添加Spring的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resources下添加applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;&lt;/beans&gt; 添加BookDao和BookDaoImpl类 12345678public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125; 创建运行类App 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 最终创建好的项目结构如下: 2.2 容器2.2.1 容器的创建方式案例中创建ApplicationContext的方式为: 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 这种方式翻译为:&#x3D;&#x3D;类路径下的XML配置文件&#x3D;&#x3D; 除了上面这种方式，Spring还提供了另外一种创建方式为: 1ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;applicationContext.xml&quot;); 这种方式翻译为:&#x3D;&#x3D;文件系统下的XML配置文件&#x3D;&#x3D; 使用这种方式，运行，会出现如下错误: 从错误信息中能发现，这种方式是从项目路径下开始查找applicationContext.xml配置文件的，所以需要将其修改为: 1ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;D:\\\\workspace\\\\spring\\\\spring_10_container\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;); **说明:**大家练习的时候，写自己的具体路径。 这种方式虽能实现，但是当项目的位置发生变化后,代码也需要跟着改,耦合度较高,不推荐使用。 2.2.2 Bean的三种获取方式方式一，就是目前案例中获取的方式: 1BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); 这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢? 方式二： 1BookDao bookDao = ctx.getBean(&quot;bookDao&quot;，BookDao.class); 这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。 方式三: 1BookDao bookDao = ctx.getBean(BookDao.class); 这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。 2.2.3 容器类层次结构(1)在IDEA中双击shift,输入BeanFactory (2)点击进入BeanFactory类，ctrl+h,就能查看到如下结构的层次关系 从图中可以看出，容器类也是从无到有根据需要一层层叠加上来的，大家重点理解下这种设计思想。 2.2.4 BeanFactory的使用使用BeanFactory来创建IOC容器的具体实现方式为: 12345678public class AppForBeanFactory &#123; public static void main(String[] args) &#123; Resource resources = new ClassPathResource(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(BookDao.class); bookDao.save(); &#125;&#125; 为了更好的看出BeanFactory和ApplicationContext之间的区别，在BookDaoImpl添加如下构造函数: 12345678public class BookDaoImpl implements BookDao &#123; public BookDaoImpl() &#123; System.out.println(&quot;constructor&quot;); &#125; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125; 如果不去获取bean对象，打印会发现： BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建 ApplicationContext是立即加载，容器加载的时候就会创建bean对象 ApplicationContext要想成为延迟加载，只需要按照如下方式进行配置 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; lazy-init=&quot;true&quot;/&gt;&lt;/beans&gt; 小结 这一节中所讲的知识点包括: 容器创建的两种方式 ClassPathXmlApplicationContext[掌握] FileSystemXmlApplicationContext[知道即可] 获取Bean的三种方式 getBean(“名称”):需要类型转换 getBean(“名称”,类型.class):多了一个参数 getBean(类型.class):容器中不能有多个该类的bean对象 上述三种方式，各有各的优缺点，用哪个都可以。 容器类层次结构 只需要知晓容器的最上级的父接口为 BeanFactory即可 BeanFactory 使用BeanFactory创建的容器是延迟加载 使用ApplicationContext创建的容器是立即加载 具体BeanFactory如何创建只需要了解即可。 2.2 核心容器总结这节中没有新的知识点，只是对前面知识的一个大总结，共包含如下内容: 2.2.1 容器相关 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 &#x3D;&#x3D;ClassPathXmlApplicationContext(常用)&#x3D;&#x3D; FileSystemXmlApplicationContext 2.2.2 bean相关 其实整个配置中最常用的就两个属性&#x3D;&#x3D;id&#x3D;&#x3D;和&#x3D;&#x3D;class&#x3D;&#x3D;。 把scope、init-method、destroy-method框起来的原因是，后面注解在讲解的时候还会用到，所以大家对这三个属性关注下。 2.2.3 依赖注入相关 3，IOC&#x2F;DI注解开发Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在&#x3D;&#x3D;配置文件&#x3D;&#x3D;。 前面咱们聊Spring的时候说过，Spring可以简化代码的开发，到现在并没有体会到。 所以Spring到底是如何简化代码开发的呢? 要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程: 2.0版开始支持注解 2.5版注解功能趋于完善 3.0版支持纯注解开发 关于注解开发，我们会讲解两块内容注解开发定义bean和纯注解开发。 注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。 3.1 环境准备在学习注解开发之前，先来准备下案例环境: 创建一个Maven项目 pom.xml添加Spring的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resources下添加applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;&lt;/beans&gt; 添加BookDao、BookDaoImpl、BookService、BookServiceImpl类 123456789101112131415161718public interface BookDao &#123; public void save();&#125;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125;public interface BookService &#123; public void save();&#125;public class BookServiceImpl implements BookService &#123; public void save() &#123; System.out.println(&quot;book service save ...&quot;); &#125;&#125; 创建运行类App 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 最终创建好的项目结构如下: 3.2 注解开发定义bean在上述环境的基础上，我们来学一学Spring是如何通过注解实现bean的定义开发? 步骤1:删除原XML配置将配置文件中的&lt;bean&gt;标签删除掉 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt; 步骤2:Dao上添加注解在BookDaoImpl类上添加@Component注解 123456@Component(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125; &#x3D;&#x3D;注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。&#x3D;&#x3D; XML与注解配置的对应关系: 步骤3:配置Spring的注解包扫描为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;/beans&gt; 说明: component-scan component:组件,Spring将管理的bean视作自己的一个组件 scan:扫描 base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。 包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快 包路径越少[如:com.itheima],扫描的范围越大速度越慢 一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。 步骤4：运行程序运行App类查看打印结果 步骤5:Service上添加注解在BookServiceImpl类上也添加@Component交给Spring框架管理 12345678910111213@Componentpublic class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; 步骤6:运行程序在App类中，从IOC容器中获取BookServiceImpl对应的bean对象，打印 12345678910public class App &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); &#125;&#125; 打印观察结果，两个bean对象都已经打印到控制台 说明: BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象 @Component注解如果不起名称，会有一个默认值就是当前类名首字母小写，所以也可以按照名称获取，如 12BookService bookService = (BookService)ctx.getBean(&quot;bookServiceImpl&quot;);System.out.println(bookService); 对于@Component注解，还衍生出了其他三个注解@Controller、@Service、@Repository 通过查看源码会发现: 这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢? 方便我们后期在编写类的时候能很好的区分出这个类是属于表现层、业务层还是数据层的类。 知识点1:@Component等 名称 @Component&#x2F;@Controller&#x2F;@Service&#x2F;@Repository 类型 类注解 位置 类定义上方 作用 设置该类为spring管理的bean 属性 value（默认）：定义bean的id 3.2 纯注解开发模式上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发 Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道 具体如何实现? 3.2.1 思路分析实现思路为: 将配置文件applicationContext.xml删除掉，使用类来替换。 3.2.2 实现步骤步骤1:创建配置类创建一个配置类SpringConfig 123public class SpringConfig &#123;&#125; 步骤2:标识该类为配置类在配置类上添加@Configuration注解，将其标识为一个配置类,替换applicationContext.xml 123@Configurationpublic class SpringConfig &#123;&#125; 步骤3:用注解替换包扫描配置在配置类上添加包扫描注解@ComponentScan替换&lt;context:component-scan base-package=&quot;&quot;/&gt; 1234@Configuration@ComponentScan(&quot;com.itheima&quot;)public class SpringConfig &#123;&#125; 步骤4:创建运行类并执行创建一个新的运行类AppForAnnotation 12345678910public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;); System.out.println(bookDao); BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); &#125;&#125; 运行AppForAnnotation,可以看到两个对象依然被获取成功 至此，纯注解开发的方式就已经完成了，主要内容包括: Java类替换Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 1@ComponentScan(&#123;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;) 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 1234//加载配置文件初始化容器ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//加载配置类初始化容器ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 知识点1：@Configuration 名称 @Configuration 类型 类注解 位置 类定义上方 作用 设置该类为spring配置类 属性 value（默认）：定义bean的id 知识点2：@ComponentScan 名称 @ComponentScan 类型 类注解 位置 类定义上方 作用 设置spring配置类扫描路径，用于加载使用注解格式定义的bean 属性 value（默认）：扫描路径，此路径可以逐层向下扫描 小结: 这一节重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为: 记住@Component、@Controller、@Service、@Repository这四个注解 applicationContext.xml中&lt;context:component-san/&gt;的作用是指定扫描包路径，注解为@ComponentScan @Configuration标识该类为配置类，使用类替换applicationContext.xml文件 ClassPathXmlApplicationContext是加载XML配置文件 AnnotationConfigApplicationContext是加载配置类 3.3 注解开发bean作用范围与生命周期管理使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:bean作用范围和bean生命周期。 3.3.1 环境准备老规矩，学习之前先来准备环境: 创建一个Maven项目 pom.xml添加Spring的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加一个配置类SpringConfig 1234@Configuration@ComponentScan(&quot;com.itheima&quot;)public class SpringConfig &#123;&#125; 添加BookDao、BookDaoImpl类 123456789public interface BookDao &#123; public void save();&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125; 创建运行类App 123456789public class App &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao1 = ctx.getBean(BookDao.class); BookDao bookDao2 = ctx.getBean(BookDao.class); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 最终创建好的项目结构如下: 3.3.2 Bean的作用范围(1)先运行App类,在控制台打印两个一摸一样的地址，说明默认情况下bean是单例 (2)要想将BookDaoImpl变成非单例，只需要在其类上添加@scope注解 123456789@Repository//@Scope设置bean的作用范围@Scope(&quot;prototype&quot;)public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125;&#125; 再次执行App类，打印结果: 知识点1：@Scope 名称 @Scope 类型 类注解 位置 类定义上方 作用 设置该类创建对象的作用范围可用于设置创建出的bean是否为单例对象 属性 value（默认）：定义bean作用范围，&#x3D;&#x3D;默认值singleton（单例），可选值prototype（非单例）&#x3D;&#x3D; 3.3.3 Bean的生命周期(1)在BookDaoImpl中添加两个方法，init和destroy,方法名可以任意 12345678910111213@Repositorypublic class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125; public void init() &#123; System.out.println(&quot;init ...&quot;); &#125; public void destroy() &#123; System.out.println(&quot;destroy ...&quot;); &#125;&#125; (2)如何对方法进行标识，哪个是初始化方法，哪个是销毁方法? 只需要在对应的方法上添加@PostConstruct和@PreDestroy注解即可。 123456789101112131415@Repositorypublic class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot;); &#125; @PostConstruct //在构造方法之后执行，替换 init-method public void init() &#123; System.out.println(&quot;init ...&quot;); &#125; @PreDestroy //在销毁方法之前执行,替换 destroy-method public void destroy() &#123; System.out.println(&quot;destroy ...&quot;); &#125;&#125; (3)要想看到两个方法执行，需要注意的是destroy只有在容器关闭的时候，才会执行，所以需要修改App的类 12345678910public class App &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao1 = ctx.getBean(BookDao.class); BookDao bookDao2 = ctx.getBean(BookDao.class); System.out.println(bookDao1); System.out.println(bookDao2); ctx.close(); //关闭容器 &#125;&#125; (4)运行App,类查看打印结果，证明init和destroy方法都被执行了。 &#x3D;&#x3D;注意:@PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包&#x3D;&#x3D; 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。 知识点1：@PostConstruct 名称 @PostConstruct 类型 方法注解 位置 方法上 作用 设置该方法为初始化方法 属性 无 知识点2：@PreDestroy 名称 @PreDestroy 类型 方法注解 位置 方法上 作用 设置该方法为销毁方法 属性 无 小结 3.4 注解开发依赖注入Spring为了使用注解简化开发，并没有提供构造函数注入、setter注入对应的注解，只提供了自动装配的注解实现。 3.4.1 环境准备在学习之前，把案例环境介绍下: 创建一个Maven项目 pom.xml添加Spring的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加一个配置类SpringConfig 1234@Configuration@ComponentScan(&quot;com.itheima&quot;)public class SpringConfig &#123;&#125; 添加BookDao、BookDaoImpl、BookService、BookServiceImpl类 1234567891011121314151617181920212223public interface BookDao &#123; public void save();&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125;public interface BookService &#123; public void save();&#125;@Servicepublic class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; 创建运行类App 1234567public class App &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ctx.getBean(BookService.class); bookService.save(); &#125;&#125; 最终创建好的项目结构如下: 环境准备好后，运行后会发现有问题 出现问题的原因是，在BookServiceImpl类中添加了BookDao的属性，并提供了setter方法，但是目前是没有提供配置注入BookDao的，所以bookDao对象为Null,调用其save方法就会报控指针异常。 3.4.2 注解实现按照类型注入对于这个问题使用注解该如何解决? (1) 在BookServiceImpl类的bookDao属性上添加@Autowired注解 12345678910111213@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; // public void setBookDao(BookDao bookDao) &#123;// this.bookDao = bookDao;// &#125; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; 注意: @Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是写在属性上并将setter方法删除掉 为什么setter方法可以删除呢? 自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值 普通反射只能获取public修饰的内容 暴力反射除了获取public修饰的内容还可以获取private修改的内容 所以此处无需提供setter方法 (2)@Autowired是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2 123456@Repositorypublic class BookDaoImpl2 implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...2&quot;); &#125;&#125; 这个时候再次运行App，就会报错 此时，按照类型注入就无法区分到底注入哪个对象，解决方案:按照名称注入 先给两个Dao类分别起个名称 123456789101112@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125;@Repository(&quot;bookDao2&quot;)public class BookDaoImpl2 implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...2&quot; ); &#125;&#125; 此时就可以注入成功，但是得思考个问题: @Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错? @Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫bookDao而容器中也有一个booDao，所以可以成功注入。 分析下面这种情况是否能完成注入呢? 不行，因为按照类型会找到多个bean对象，此时会按照bookDao名称去找，因为IOC容器只有名称叫bookDao1和bookDao2,所以找不到，会报NoUniqueBeanDefinitionException 3.4.3 注解实现按照名称注入当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到@Qualifier来指定注入哪个名称的bean对象。 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired @Qualifier(&quot;bookDao1&quot;) private BookDao bookDao; public void save() &#123; System.out.println(&quot;book service save ...&quot;); bookDao.save(); &#125;&#125; @Qualifier注解后的值就是需要注入的bean的名称。 &#x3D;&#x3D;注意:@Qualifier不能独立使用，必须和@Autowired一起使用&#x3D;&#x3D; 3.4.4 简单数据类型注入引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在BookDaoImpl类中添加一个name属性，用其进行简单类型注入 1234567@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123; private String name; public void save() &#123; System.out.println(&quot;book dao save ...&quot; + name); &#125;&#125; 数据类型换了，对应的注解也要跟着换，这次使用@Value注解，将值写入注解的参数中就行了 12345678@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123; @Value(&quot;itheima&quot;) private String name; public void save() &#123; System.out.println(&quot;book dao save ...&quot; + name); &#125;&#125; 注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。 介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么? 3.4.5 注解读取properties配置文件@Value一般会被用在从properties配置文件中读取内容进行使用，具体如何实现? 步骤1：resource下准备properties文件jdbc.properties 1name=itheima888 步骤2: 使用注解加载properties配置文件在配置类上添加@PropertySource注解 123456@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125; 步骤3：使用@Value读取配置文件中的内容12345678@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; public void save() &#123; System.out.println(&quot;book dao save ...&quot; + name); &#125;&#125; 步骤4:运行程序 运行App类，查看运行结果，说明配置文件中的内容已经被加载到 注意: 如果读取的properties配置文件有多个，可以使用@PropertySource的属性来指定多个 1@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;) @PropertySource注解属性中不支持使用通配符*,运行会报错 1@PropertySource(&#123;&quot;*.properties&quot;&#125;) @PropertySource注解属性中可以把classpath:加上,代表从当前项目的根路径找文件 1@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;) 知识点1：@Autowired 名称 @Autowired 类型 属性注解 或 方法注解（了解） 或 方法形参注解（了解） 位置 属性定义上方 或 标准set方法上方 或 类set方法上方 或 方法形参前面 作用 为引用类型属性设置值 属性 required：true&#x2F;false，定义该属性是否允许为null 知识点2：@Qualifier 名称 @Qualifier 类型 属性注解 或 方法注解（了解） 位置 属性定义上方 或 标准set方法上方 或 类set方法上方 作用 为引用类型属性指定注入的beanId 属性 value（默认）：设置注入的beanId 知识点3：@Value 名称 @Value 类型 属性注解 或 方法注解（了解） 位置 属性定义上方 或 标准set方法上方 或 类set方法上方 作用 为 基本数据类型 或 字符串类型 属性设置值 属性 value（默认）：要注入的属性值 知识点4：@PropertySource 名称 @PropertySource 类型 类注解 位置 类定义上方 作用 加载properties文件中的属性值 属性 value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组 4，IOC&#x2F;DI注解开发管理第三方bean前面定义bean的时候都是在自己开发的类上面写个注解就完成了，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解，这个时候该怎么办? 遇到上述问题，我们就需要有一种更加灵活的方式来定义bean,这种方式不能在原始代码上面书写注解，一样能定义bean,这就用到了一个全新的注解&#x3D;&#x3D;@Bean&#x3D;&#x3D;。 这个注解该如何使用呢? 咱们把之前使用配置方式管理的数据源使用注解再来一遍，通过这个案例来学习下@Bean的使用。 4.1 环境准备学习@Bean注解之前先来准备环境: 创建一个Maven项目 pom.xml添加Spring的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加一个配置类SpringConfig 123@Configurationpublic class SpringConfig &#123;&#125; 添加BookDao、BookDaoImpl类 123456789public interface BookDao &#123; public void save();&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save ...&quot; ); &#125;&#125; 创建运行类App 12345public class App &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); &#125;&#125; 最终创建好的项目结构如下: 4.2 注解开发管理第三方bean在上述环境中完成对Druid数据源的管理，具体的实现步骤为: 步骤1:导入对应的jar包12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 步骤2:在配置类中添加一个方法注意该方法的返回值就是要创建的Bean对象类型 1234567891011@Configurationpublic class SpringConfig &#123; public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 步骤3:在方法上添加@Bean注解@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象 123456789101112@Configurationpublic class SpringConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 注意:不能使用DataSource ds = new DruidDataSource() 因为DataSource接口中没有对应的setter方法来设置属性。 步骤4:从IOC容器中获取对象并打印1234567public class App &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource); &#125;&#125; 至此使用@Bean来管理第三方bean的案例就已经完成。 如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。 4.3 引入外部配置类如果把所有的第三方bean都配置到Spring的配置类SpringConfig中，虽然可以，但是不利于代码阅读和分类管理，所有我们就想能不能按照类别将这些bean配置到不同的配置类中? 对于数据源的bean,我们新建一个JdbcConfig配置类，并把数据源配置到该类下。 1234567891011public class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 现在的问题是，这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中? 针对这个问题，有两个解决方案: 4.3.1 使用包扫描引入步骤1:在Spring的配置类上添加包扫描12345@Configuration@ComponentScan(&quot;com.itheima.config&quot;)public class SpringConfig &#123; &#125; 步骤2:在JdbcConfig上添加配置注解JdbcConfig类要放入到com.itheima.config包下，需要被Spring的配置类扫描到即可 123456789101112@Configurationpublic class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 步骤3:运行程序依然能获取到bean对象并打印控制台。 这种方式虽然能够扫描到，但是不能很快的知晓都引入了哪些配置类，所有这种方式不推荐使用。 4.3.2 使用@Import引入方案一实现起来有点小复杂，Spring早就想到了这一点，于是又给我们提供了第二种方案。 这种方案可以不用加@Configuration注解，但是必须在Spring配置类上使用@Import注解手动引入需要加载的配置类 步骤1:去除JdbcConfig类上的注解1234567891011public class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 步骤2:在Spring配置类中引入123456@Configuration//@ComponentScan(&quot;com.itheima.config&quot;)@Import(&#123;JdbcConfig.class&#125;)public class SpringConfig &#123; &#125; 注意: 扫描注解可以移除 @Import参数需要的是一个数组，可以引入多个配置类。 @Import注解在配置类中只能写一次，下面的方式是&#x3D;&#x3D;不允许的&#x3D;&#x3D; 1234567@Configuration//@ComponentScan(&quot;com.itheima.config&quot;)@Import(JdbcConfig.class)@Import(Xxx.class)public class SpringConfig &#123; &#125; 步骤3:运行程序依然能获取到bean对象并打印控制台 知识点1：@Bean 名称 @Bean 类型 方法注解 位置 方法定义上方 作用 设置该方法的返回值作为spring管理的bean 属性 value（默认）：定义bean的id 知识点2：@Import 名称 @Import 类型 类注解 位置 类定义上方 作用 导入配置类 属性 value（默认）：定义导入的配置类类名，当配置类有多个时使用数组格式一次性导入多个配置类 4.4 注解开发实现为第三方bean注入资源在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办? 这些资源会有两大类，分别是简单数据类型 和引用数据类型。 4.4.1 简单数据类型4.4.1.1 需求分析对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取。如何来优化下面的代码? 1234567891011public class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 4.4.1.2 注入简单数据类型步骤步骤1:类中提供四个属性123456789101112131415public class JdbcConfig &#123; private String driver; private String url; private String userName; private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 步骤2:使用@Value注解引入值12345678910111213141516171819public class JdbcConfig &#123; @Value(&quot;com.mysql.jdbc.Driver&quot;) private String driver; @Value(&quot;jdbc:mysql://localhost:3306/spring_db&quot;) private String url; @Value(&quot;root&quot;) private String userName; @Value(&quot;password&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 扩展现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提 取到jdbc.properties配置文件，大家思考下该如何实现? 1.resources目录下添加jdbc.properties 2.配置文件中提供四个键值对分别是数据库的四要素 3.使用@PropertySource加载jdbc.properties配置文件 4.修改@Value注解属性的值，将其修改为$&#123;key&#125;，key就是键值对中的键的值 具体的实现就交由大家自行实现下。 4.4.2 引用数据类型4.4.2.1 需求分析假设在构建DataSource对象的时候，需要用到BookDao对象，该如何把BookDao对象注入进方法内让其使用呢? 1234567891011public class JdbcConfig &#123; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring_db&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); return ds; &#125;&#125; 4.4.2.2 注入引用数据类型步骤步骤1:在SpringConfig中扫描BookDao扫描的目的是让Spring能管理到BookDao,也就是说要让IOC容器中有一个bookDao对象 12345@Configuration@ComponentScan(&quot;com.itheima.dao&quot;)@Import(&#123;JdbcConfig.class&#125;)public class SpringConfig &#123;&#125; 步骤2:在JdbcConfig类的方法上添加参数12345678910@Beanpublic DataSource dataSource(BookDao bookDao)&#123; System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds;&#125; &#x3D;&#x3D;引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。&#x3D;&#x3D; 步骤3:运行程序 5，注解开发总结前面我们已经完成了XML配置和注解的开发实现，至于两者之间的差异，咱们放在一块去对比回顾下: 6，Spring整合课程学习到这里，已经对Spring有一个简单的认识了，Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，其实除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方bean了，下面结合IoC和DI，整合2个常用技术，进一步加深对Spring的使用理解。 6.1 Spring整合Mybatis思路分析6.1.1 环境准备在准备环境的过程中，我们也来回顾下Mybatis开发的相关内容: 步骤1:准备数据库表Mybatis是来操作数据库表，所以先创建一个数据库及表 1234567create database spring_db character set utf8;use spring_db;create table tbl_account( id int primary key auto_increment, name varchar(35), money double); 步骤2:创建项目导入jar包项目的pom.xml添加相关依赖 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 步骤3:根据表创建模型类1234567public class Account implements Serializable &#123; private Integer id; private String name; private Double money; //setter...getter...toString...方法略 &#125; 步骤4:创建Dao接口1234567891011121314151617public interface AccountDao &#123; @Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;) void save(Account account); @Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;) void delete(Integer id); @Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;) void update(Account account); @Select(&quot;select * from tbl_account&quot;) List&lt;Account&gt; findAll(); @Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;) Account findById(Integer id);&#125; 步骤5:创建Service接口和实现类12345678910111213141516171819202122232425262728293031323334353637383940public interface AccountService &#123; void save(Account account); void delete(Integer id); void update(Account account); List&lt;Account&gt; findAll(); Account findById(Integer id);&#125;@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; public void save(Account account) &#123; accountDao.save(account); &#125; public void update(Account account)&#123; accountDao.update(account); &#125; public void delete(Integer id) &#123; accountDao.delete(id); &#125; public Account findById(Integer id) &#123; return accountDao.findById(id); &#125; public List&lt;Account&gt; findAll() &#123; return accountDao.findAll(); &#125;&#125; 步骤6:添加jdbc.properties文件resources目录下添加，用于配置数据库连接四要素 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=falsejdbc.username=rootjdbc.password=root useSSL:关闭MySQL的SSL连接 步骤7:添加Mybatis核心配置文件12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--读取外部properties配置文件--&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; &lt;!--别名扫描的包路径--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;!--数据源--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--映射文件扫描包路径--&gt; &lt;mappers&gt; &lt;package name=&quot;com.itheima.dao&quot;&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 步骤8:编写应用程序1234567891011121314151617181920public class App &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml.bak&quot;); // 3. 创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // 4. 获取SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User AccountDao accountDao = sqlSession.getMapper(AccountDao.class); Account ac = accountDao.findById(1); System.out.println(ac); // 6. 释放资源 sqlSession.close(); &#125;&#125; 步骤9:运行程序 6.1.2 整合思路分析Mybatis的基础环境我们已经准备好了，接下来就得分析下在上述的内容中，哪些对象可以交给Spring来管理? Mybatis程序核心对象分析 从图中可以获取到，真正需要交给Spring管理的是&#x3D;&#x3D;SqlSessionFactory&#x3D;&#x3D; 整合Mybatis，就是将Mybatis用到的内容交给Spring管理，分析下配置文件 说明: 第一行读取外部properties配置文件，Spring有提供具体的解决方案@PropertySource,需要交给Spring 第二行起别名包扫描，为SqlSessionFactory服务的，需要交给Spring 第三行主要用于做连接池，Spring之前我们已经整合了Druid连接池，这块也需要交给Spring 前面三行一起都是为了创建SqlSession对象用的，那么用Spring管理SqlSession对象吗?回忆下SqlSession是由SqlSessionFactory创建出来的，所以只需要将SqlSessionFactory交给Spring管理即可。 第四行是Mapper接口和映射文件[如果使用注解就没有该映射文件]，这个是在获取到SqlSession以后执行具体操作的时候用，所以它和SqlSessionFactory创建的时机都不在同一个时间，可能需要单独管理。 6.2 Spring整合Mybatis前面我们已经分析了Spring与Mybatis的整合，大体需要做两件事， 第一件事是:Spring要管理MyBatis中的SqlSessionFactory 第二件事是:Spring要管理Mapper接口的扫描 具体该如何实现，具体的步骤为: 步骤1:项目中导入整合需要的jar包123456789101112131415&lt;dependency&gt; &lt;!--Spring操作数据库需要该jar包--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!-- Spring与Mybatis整合的jar包 这个jar包mybatis在前面，是Mybatis提供的 --&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; 步骤2:创建Spring的主配置类1234567//配置类注解@Configuration//包扫描，主要扫描的是项目中的AccountServiceImpl类@ComponentScan(&quot;com.itheima&quot;)public class SpringConfig &#123;&#125; 步骤3:创建数据源的配置类在配置类中完成数据源的创建 1234567891011121314151617181920public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 步骤4:主配置类中读properties并引入数据源配置类1234567@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(JdbcConfig.class)public class SpringConfig &#123;&#125; 步骤5:创建Mybatis配置类并配置SqlSessionFactory12345678910111213141516171819public class MybatisConfig &#123; //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123; SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); //设置模型类的别名扫描 ssfb.setTypeAliasesPackage(&quot;com.itheima.domain&quot;); //设置数据源 ssfb.setDataSource(dataSource); return ssfb; &#125; //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.itheima.dao&quot;); return msc; &#125;&#125; 说明: 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 SqlSessionFactoryBean是前面我们讲解FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，我们只需要将其需要的内容设置即可。 方法中有一个参数为dataSource,当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象。 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 这个MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置，加载数据层的Mapper接口类 MapperScannerConfigurer有一个核心属性basePackage，就是用来设置所扫描的包路径 步骤6:主配置类中引入Mybatis配置类123456@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)public class SpringConfig &#123;&#125; 步骤7:编写运行类在运行类中，从IOC容器中获取Service对象，调用方法获取结果 1234567891011public class App2 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); &#125;&#125; 步骤8:运行程序 支持Spring与Mybatis的整合就已经完成了，其中主要用到的两个类分别是: &#x3D;&#x3D;SqlSessionFactoryBean&#x3D;&#x3D; &#x3D;&#x3D;MapperScannerConfigurer&#x3D;&#x3D; 6.3 Spring整合Junit整合Junit与整合Druid和MyBatis差异比较大，为什么呢？Junit是一个搞单元测试用的工具，它不是我们程序的主体，也不会参加最终程序的运行，从作用上来说就和之前的东西不一样，它不是做功能的，看做是一个辅助工具就可以了。 6.3.1 环境准备这块环境，大家可以直接使用Spring与Mybatis整合的环境即可。当然也可以重新创建一个，因为内容是一模一样，所以我们直接来看下项目结构即可: 6.3.2 整合Junit步骤在上述环境的基础上，我们来对Junit进行整合。 步骤1:引入依赖pom.xml 123456789101112&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; 步骤2:编写测试类在test\\java下创建一个AccountServiceTest,这个名字任意 12345678910111213141516171819//设置类运行器@RunWith(SpringJUnit4ClassRunner.class)//设置Spring环境对应的配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) //加载配置类//@ContextConfiguration(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载配置文件public class AccountServiceTest &#123; //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById()&#123; System.out.println(accountService.findById(1)); &#125; @Test public void testFindAll()&#123; System.out.println(accountService.findAll()); &#125;&#125; 注意: 单元测试，如果测试的是注解配置类，则使用@ContextConfiguration(classes = 配置类.class) 单元测试，如果测试的是配置文件，则使用@ContextConfiguration(locations=&#123;配置文件名,...&#125;) Junit运行后是基于Spring环境运行的，所以Spring提供了一个专用的类运行器，这个务必要设置，这个类运行器就在Spring的测试专用包中提供的，导入的坐标就是这个东西SpringJUnit4ClassRunner 上面两个配置都是固定格式，当需要测试哪个bean时，使用自动装配加载对应的对象，下面的工作就和以前做Junit单元测试完全一样了 知识点1：@RunWith 名称 @RunWith 类型 测试类注解 位置 测试类定义上方 作用 设置JUnit运行器 属性 value（默认）：运行所使用的运行期 知识点2：@ContextConfiguration 名称 @ContextConfiguration 类型 测试类注解 位置 测试类定义上方 作用 设置JUnit加载的Spring核心配置 属性 classes：核心配置类，可以使用数组的格式设定加载多个配置类locations:配置文件，可以使用数组的格式设定加载多个配置文件名称","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.tangyongao.top/categories/Spring/"}],"tags":[{"name":"Spring笔记","slug":"Spring笔记","permalink":"https://www.tangyongao.top/tags/Spring%E7%AC%94%E8%AE%B0/"}],"author":["唐 某 某"]},{"title":"Mybatis","slug":"Mybatis","date":"2022-11-21T07:12:17.933Z","updated":"2022-12-04T12:04:50.985Z","comments":true,"path":"2022/11/21/Mybatis/","link":"","permalink":"https://www.tangyongao.top/2022/11/21/Mybatis/","excerpt":"","text":"Mybatis练习目标 能够使用映射配置文件实现CRUD操作 能够使用注解实现CRUD操作 1，配置文件实现CRUD 如上图所示产品原型，里面包含了品牌数据的 查询 、按条件查询、添加、删除、批量删除、修改 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表： 查询 查询所有数据 查询详情 条件查询 添加 修改 修改全部字段 修改动态字段 删除 删除一个 批量删除 我们先将必要的环境准备一下。 1.1 环境准备 数据库表（tb_brand）及数据准备 1234567891011121314151617181920212223-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1); 实体类 Brand 在 com.itheima.pojo 包下创建 Brand 实体类。 12345678910111213141516public class Brand &#123; // id 主键 private Integer id; // 品牌名称 private String brandName; // 企业名称 private String companyName; // 排序字段 private Integer ordered; // 描述信息 private String description; // 状态：0：禁用 1：启用 private Integer status; //省略 setter and getter。自己写时要补全这部分代码&#125; 编写测试用例 测试代码需要在 test/java 目录下创建包及测试用例。项目结构如下： 安装 MyBatisX 插件 MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。 主要功能 XML映射配置文件 和 接口方法 间相互跳转 根据接口方法生成 statement 安装方式 点击 file ，选择 settings ，就能看到如下图所示界面 注意：安装完毕后需要重启IDEA 插件效果 红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 statement ，如图所示 1.2 查询所有数据 如上图所示就页面上展示的数据，而这些数据需要从数据库进行查询。接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现： 编写接口方法：Mapper接口 参数：无 查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。 结果：List 我们会将查询出来的每一条数据封装成一个 Brand 对象，而多条数据封装多个 Brand 对象，需要将这些对象封装到List集合中返回。 执行方法、测试 1.2.1 编写接口方法在 com.itheima.mapper 包写创建名为 BrandMapper 的接口。并在该接口中定义 List&lt;Brand&gt; selectAll() 方法。 1234567public interface BrandMapper &#123; /** * 查询所有 */ List&lt;Brand&gt; selectAll();&#125; 1.2.2 编写SQL语句在 reources 下创建 com/itheima/mapper 目录结构，并在该目录下创建名为 BrandMapper.xml 的映射配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.BrandMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select * from tb_brand; &lt;/select&gt;&lt;/mapper&gt; 1.2.3 编写测试方法在 MybatisTest 类中编写测试查询所有的方法 123456789101112131415161718192021@Testpublic void testSelectAll() throws IOException &#123; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 List&lt;Brand&gt; brands = brandMapper.selectAll(); System.out.println(brands); //5. 释放资源 sqlSession.close();&#125; 注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。 执行测试方法结果如下： 从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？ 这个问题可以通过两种方式进行解决： 给字段起别名 使用resultMap定义字段和属性的映射关系 1.2.4 起别名解决上述问题从上面结果可以看到 brandName 和 companyName 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 brandName 和 companyName ，而表中的字段名为 brand_name 和 company_name，如下图所示 。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。 我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。 12345&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select id, brand_name as brandName, company_name as companyName, ordered, description, status from tb_brand;&lt;/select&gt; 而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了sql 片段可以提高sql的复用性。 SQL片段： 将需要复用的SQL片段抽取到 sql 标签中 123&lt;sql id=&quot;brand_column&quot;&gt; id, brand_name as brandName, company_name as companyName, ordered, description, status&lt;/sql&gt; id属性值是唯一标识，引用时也是通过该值进行引用。 在原sql语句中进行引用 使用 include 标签引用上述的 SQL 片段，而 refid 指定上述 SQL 片段的id值。 12345&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select &lt;include refid=&quot;brand_column&quot; /&gt; from tb_brand;&lt;/select&gt; 1.2.5 使用resultMap解决上述问题起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。 那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。 在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系 123456789101112&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;&lt;/resultMap&gt; 注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。 SQL语句正常编写 1234&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand;&lt;/select&gt; 1.2.6 小结实体类属性名 和 数据库表列名 不一致，不能自动封装数据 &#x3D;&#x3D;起别名：&#x3D;&#x3D;在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样 可以定义 片段，提升复用性 &#x3D;&#x3D;resultMap：&#x3D;&#x3D;定义 完成不一致的属性名和列名的映射 而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下： 12345678910111213141516171819 &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand;&lt;/select&gt; 1.3 查询详情 有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 查看详情 来进行查询，如上图所示。 查看详情功能实现步骤： 编写接口方法：Mapper接口 参数：id 查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。 结果：Brand 根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可 编写SQL语句：SQL映射文件 执行方法、进行测试 1.3.1 编写接口方法在 BrandMapper 接口中定义根据id查询数据的方法 1234/** * 查看详情：根据Id查询 */Brand selectById(int id); 1.3.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType 1234&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = #&#123;id&#125;;&lt;/select&gt; 注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解 1.3.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 1234567891011121314151617181920212223 @Testpublic void testSelectById() throws IOException &#123; //接收参数，该id以后需要传递过来 int id = 1; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 Brand brand = brandMapper.selectById(id); System.out.println(brand); //5. 释放资源 sqlSession.close();&#125; 执行测试方法结果如下： 1.3.4 参数占位符查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 #&#123;id&#125; 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。 mybatis提供了两种参数占位符： #{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 PreparedStatement ${} ：拼接SQL。底层使用的是 Statement，会存在SQL注入问题。如下图将 映射配置文件中的 #{} 替换成 ${} 来看效果 1234&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = $&#123;id&#125;;&lt;/select&gt; 重新运行查看结果如下： &#x3D;&#x3D;注意：&#x3D;&#x3D;从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。 1.3.5 parameterType使用对于有参数的mapper接口方法，我们在映射配置文件中应该配置 ParameterType 来指定参数类型。只不过该属性都可以省略。如下图： 1234&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = $&#123;id&#125;;&lt;/select&gt; 1.3.6 SQL语句中特殊字段处理以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值，如下图 可以看出报错了，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义 转义字符 下图的 &amp;lt; 就是 &lt; 的转义字符。 1.4 多条件查询 我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题 条件表达式 如何连接 条件字段 企业名称 和 品牌名称 需要进行模糊查询，所以条件应该是： 简单的分析后，我们来看功能实现的步骤： 编写接口方法 参数：所有查询条件 结果：List 在映射配置文件中编写SQL语句 编写测试方法并执行 1.4.1 编写接口方法在 BrandMapper 接口中定义多条件查询的方法。 而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现 使用 @Param(&quot;参数名称&quot;) 标记每一个参数，在映射配置文件中就需要使用 #&#123;参数名称&#125; 进行占位 1List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName,@Param(&quot;brandName&quot;) String brandName); 将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和实体类属性名保持一致。 1List&lt;Brand&gt; selectByCondition(Brand brand); 将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和map集合中键的名称一致。 1List&lt;Brand&gt; selectByCondition(Map map); 1.4.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType 1234567&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where status = #&#123;status&#125; and company_name like #&#123;companyName&#125; and brand_name like #&#123;brandName&#125;&lt;/select&gt; 1.4.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void testSelectByCondition() throws IOException &#123; //接收参数 int status = 1; String companyName = &quot;华为&quot;; String brandName = &quot;华为&quot;; // 处理参数 companyName = &quot;%&quot; + companyName + &quot;%&quot;; brandName = &quot;%&quot; + brandName + &quot;%&quot;; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 //方式一 ：接口方法参数使用 @Param 方式调用的方法 //List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName); //方式二 ：接口方法参数是 实体类对象 方式调用的方法 //封装对象 /* Brand brand = new Brand(); brand.setStatus(status); brand.setCompanyName(companyName); brand.setBrandName(brandName);*/ //List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand); //方式三 ：接口方法参数是 map集合对象 方式调用的方法 Map map = new HashMap(); map.put(&quot;status&quot; , status); map.put(&quot;companyName&quot;, companyName); map.put(&quot;brandName&quot; , brandName); List&lt;Brand&gt; brands = brandMapper.selectByCondition(map); System.out.println(brands); //5. 释放资源 sqlSession.close();&#125; 1.4.4 动态SQL上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的 例如用户只输入 当前状态 时，SQL语句就是 1select * from tb_brand where status = #&#123;status&#125; 而用户如果只输入企业名称时，SQL语句就是 1select * from tb_brand where company_name like #&#123;companName&#125; 而用户如果输入了 当前状态 和 企业名称 时，SQL语句又不一样 1select * from tb_brand where status = #&#123;status&#125; and company_name like #&#123;companName&#125; 针对上述的需要，Mybatis对动态SQL有很强大的支撑： if choose (when, otherwise) trim (where, set) foreach 我们先学习 if 标签和 where 标签： if 标签：条件判断 test 属性：逻辑表达式 1234567891011121314&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt;&lt;/select&gt; 如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。 执行结果如下： 但是它也存在问题，如果此时给的参数值是 1234Map map = new HashMap();// map.put(&quot;status&quot; , status);map.put(&quot;companyName&quot;, companyName);map.put(&quot;brandName&quot; , brandName); 拼接的SQL语句就变成了 1select * from tb_brand where and company_name like ? and brand_name like ? 而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决 where 标签 作用： 替换where关键字 会动态的去掉第一个条件前的 and 如果所有的参数没有值则不加where关键字 123456789101112131415&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 注意：需要给每个条件前都加上 and 关键字。 1.5 单个条件（动态SQL） 如上图所示，在查询时只能选择 品牌名称、当前状态、企业名称 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 这种需求需要使用到 choose（when，otherwise）标签 实现， 而 choose 标签类似于Java 中的switch语句。 通过一个案例来使用这些标签 1.5.1 编写接口方法在 BrandMapper 接口中定义单条件查询的方法。 123456/** * 单条件动态查询 * @param brand * @return */List&lt;Brand&gt; selectByConditionSingle(Brand brand); 1.5.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType 1234567891011121314151617&lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;choose&gt;&lt;!--相当于switch--&gt; &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt; status = #&#123;status&#125; &lt;/when&gt; &lt;when test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;&lt;!--相当于case--&gt; company_name like #&#123;companyName&#125; &lt;/when&gt; &lt;when test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt;&lt;!--相当于case--&gt; brand_name like #&#123;brandName&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 1.5.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 1234567891011121314151617181920212223242526272829303132@Testpublic void testSelectByConditionSingle() throws IOException &#123; //接收参数 int status = 1; String companyName = &quot;华为&quot;; String brandName = &quot;华为&quot;; // 处理参数 companyName = &quot;%&quot; + companyName + &quot;%&quot;; brandName = &quot;%&quot; + brandName + &quot;%&quot;; //封装对象 Brand brand = new Brand(); //brand.setStatus(status); brand.setCompanyName(companyName); //brand.setBrandName(brandName); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand); System.out.println(brands); //5. 释放资源 sqlSession.close();&#125; 执行测试方法结果如下： 1.6 添加数据 如上图是我们平时在添加数据时展示的页面，而我们在该页面输入想要的数据后添加 提交 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作。 编写接口方法 参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 &#x3D;&#x3D;自动增长&#x3D;&#x3D; 生成的。 编写SQL语句 编写测试方法并执行 明确了该功能实现的步骤后，接下来我们进行具体的操作。 1.6.1 编写接口方法在 BrandMapper 接口中定义添加方法。 1234 /** * 添加 */void add(Brand brand); 1.6.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写添加数据的 statement 1234&lt;insert id=&quot;add&quot;&gt; insert into tb_brand (brand_name, company_name, ordered, description, status) values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);&lt;/insert&gt; 1.6.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021222324252627282930313233@Testpublic void testAdd() throws IOException &#123; //接收参数 int status = 1; String companyName = &quot;波导手机&quot;; String brandName = &quot;波导&quot;; String description = &quot;手机中的战斗机&quot;; int ordered = 100; //封装对象 Brand brand = new Brand(); brand.setStatus(status); brand.setCompanyName(companyName); brand.setBrandName(brandName); brand.setDescription(description); brand.setOrdered(ordered); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了 //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.add(brand); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 执行结果如下： 1.6.4 添加-主键返回在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。 比如：添加订单和订单项，如下图就是京东上的订单 订单数据存储在订单表中，订单项存储在订单项表中。 添加订单数据 添加订单项数据，订单项中需要设置所属订单的id 明白了什么时候 主键返回 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。 我们将上面添加品牌数据的案例中映射配置文件里 statement 进行修改，如下 1234&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into tb_brand (brand_name, company_name, ordered, description, status) values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);&lt;/insert&gt; 在 insert 标签上添加如下属性： useGeneratedKeys：是够获取自动增长的主键值。true表示获取 keyProperty ：指定将获取到的主键值封装到哪儿个属性里 1.7 修改 如图所示是修改页面，用户在该页面书写需要修改的数据，点击 提交 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪儿个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。 接下来我们就具体来实现 1.7.1 编写接口方法在 BrandMapper 接口中定义修改方法。 1234 /** * 修改 */void update(Brand brand); 上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。 1.7.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写修改数据的 statement。 123456789101112131415161718192021&lt;update id=&quot;update&quot;&gt; update tb_brand &lt;set&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt; brand_name = #&#123;brandName&#125;, &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt; company_name = #&#123;companyName&#125;, &lt;/if&gt; &lt;if test=&quot;ordered != null&quot;&gt; ordered = #&#123;ordered&#125;, &lt;/if&gt; &lt;if test=&quot;description != null and description != &#x27;&#x27;&quot;&gt; description = #&#123;description&#125;, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; status = #&#123;status&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;;&lt;/update&gt; set 标签可以用于动态包含需要更新的列，忽略其它不更新的列。 1.7.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021222324252627282930313233343536@Testpublic void testUpdate() throws IOException &#123; //接收参数 int status = 0; String companyName = &quot;波导手机&quot;; String brandName = &quot;波导&quot;; String description = &quot;波导手机,手机中的战斗机&quot;; int ordered = 200; int id = 6; //封装对象 Brand brand = new Brand(); brand.setStatus(status); // brand.setCompanyName(companyName); // brand.setBrandName(brandName); // brand.setDescription(description); // brand.setOrdered(ordered); brand.setId(id); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 int count = brandMapper.update(brand); System.out.println(count); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 执行测试方法结果如下： 从结果中SQL语句可以看出，只修改了 status 字段值，因为我们给的数据中只给Brand实体对象的 status 属性设置值了。这就是 set 标签的作用。 1.8 删除一行数据 如上图所示，每行数据后面都有一个 删除 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。 接下来就来实现该功能。 1.8.1 编写接口方法在 BrandMapper 接口中定义根据id删除方法。 1234/** * 根据id删除 */void deleteById(int id); 1.8.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写删除一行数据的 statement 123&lt;delete id=&quot;deleteById&quot;&gt; delete from tb_brand where id = #&#123;id&#125;;&lt;/delete&gt; 1.8.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021 @Testpublic void testDeleteById() throws IOException &#123; //接收参数 int id = 6; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.deleteById(id); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 运行过程只要没报错，直接到数据库查询数据是否还存在。 1.9 批量删除 如上图所示，用户可以选择多条数据，然后点击上面的 删除 按钮，就会删除数据库中对应的多行数据。 1.9.1 编写接口方法在 BrandMapper 接口中定义删除多行数据的方法。 1234/** * 批量删除 */void deleteByIds(int[] ids); 参数是一个数组，数组中存储的是多条数据的id 1.9.2 编写SQL语句在 BrandMapper.xml 映射配置文件中编写删除多条数据的 statement。 编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 foreach 标签供我们使用 foreach 标签 用来迭代任何可迭代的对象（如数组，集合）。 collection 属性： mybatis会将数组参数，封装为一个Map集合。 默认：array &#x3D; 数组 使用@Param注解改变map集合的默认key的名称 item 属性：本次迭代获取到的元素。 separator 属性：集合项迭代之间的分隔符。foreach 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。 open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次 close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次 12345678&lt;delete id=&quot;deleteByIds&quot;&gt; delete from tb_brand where id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; ;&lt;/delete&gt; 假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是： 1delete from tb_brand where id in (1,2,3); 1.9.3 编写测试方法在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021@Testpublic void testDeleteByIds() throws IOException &#123; //接收参数 int[] ids = &#123;5,7,8&#125;; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.deleteByIds(ids); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 1.10 Mybatis参数传递Mybatis 接口方法中可以接收各种各样的参数，如下： 多个参数 单个参数：单个参数又可以是如下类型 POJO 类型 Map 集合类型 Collection 集合类型 List 集合类型 Array 类型 其他类型 1.10.1 多个参数如下面的代码，就是接收两个参数，而接收多个参数需要使用 @Param 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。 1User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; 我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 @Param 注解时有以下命名规则： 以 arg 开头 ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如： map.put(“arg0”，参数值1); map.put(“arg1”，参数值2); 以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如： map.put(“param1”，参数值1); map.put(“param2”，参数值2); 代码验证： 在 UserMapper 接口中定义如下方法 1User select(String username,String password); 在 UserMapper.xml 映射配置文件中定义SQL 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;arg0&#125; and password=#&#123;arg1&#125;&lt;/select&gt; 或者 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;param1&#125; and password=#&#123;param2&#125;&lt;/select&gt; 运行代码结果如下 在映射配合文件的SQL语句中使用用 arg 开头的和 param 书写，代码的可读性会变的特别差，此时可以使用 @Param 注解。 在接口方法参数上使用 @Param 注解，Mybatis 会将 arg 开头的键名替换为对应注解的属性值。 代码验证： 在 UserMapper 接口中定义如下方法，在 username 参数前加上 @Param 注解 1User select(@Param(&quot;username&quot;) String username, String password); Mybatis 在封装 Map 集合时，键名就会变成如下： map.put(“username”，参数值1); map.put(“arg1”，参数值2); map.put(“param1”，参数值1); map.put(“param2”，参数值2); 在 UserMapper.xml 映射配置文件中定义SQL 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;username&#125; and password=#&#123;param2&#125;&lt;/select&gt; 运行程序结果没有报错。而如果将 #&#123;&#125; 中的 username 还是写成 arg0 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;arg0&#125; and password=#&#123;param2&#125;&lt;/select&gt; 运行程序则可以看到错误 &#x3D;&#x3D;结论：以后接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。&#x3D;&#x3D; 1.10.2 单个参数 POJO 类型 直接使用。要求 属性名 和 参数占位符名称 一致 Map 集合类型 直接使用。要求 map集合的键名 和 参数占位符名称 一致 Collection 集合类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，collection集合); map.put(“collection”，collection集合; &#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D; List 集合类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，list集合); map.put(“collection”，list集合); map.put(“list”，list集合); &#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D; Array 类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，数组); map.put(“array”，数组); &#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D; 其他类型 比如int类型，参数占位符名称 叫什么都可以。尽量做到见名知意 2，注解实现CRUD使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发 12@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)public User select(int id); &#x3D;&#x3D;注意：&#x3D;&#x3D; 注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 statement Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下： 查询 ：@Select 添加 ：@Insert 修改 ：@Update 删除 ：@Delete 接下来我们做一个案例来使用 Mybatis 的注解开发 代码实现： 将之前案例中 UserMapper.xml 中的 根据id查询数据 的 statement 注释掉 在 UserMapper 接口的 selectById 方法上添加注解 运行测试程序也能正常查询到数据 我们课程上只演示这一个查询的注解开发，其他的同学们下来可以自己实现，都是比较简单。 &#x3D;&#x3D;注意：&#x3D;&#x3D;在官方文档中 入门 中有这样的一段话： 所以，&#x3D;&#x3D;注解完成简单功能，配置文件完成复杂功能。&#x3D;&#x3D; 而我们之前写的动态 SQL 就是复杂的功能，如果用注解使用的话，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下： 上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://www.tangyongao.top/categories/mybatis/"}],"tags":[{"name":"mabatis 笔记","slug":"mabatis-笔记","permalink":"https://www.tangyongao.top/tags/mabatis-%E7%AC%94%E8%AE%B0/"}],"author":["唐 某 某"]},{"title":"Mysql","slug":"MySql","date":"2022-11-16T10:25:53.109Z","updated":"2022-12-04T12:05:44.011Z","comments":true,"path":"2022/11/16/MySql/","link":"","permalink":"https://www.tangyongao.top/2022/11/16/MySql/","excerpt":"","text":"MySql1：SQL语句可以单行或多行书写，以分号结尾。2.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写3.注释单行注释：– 注释内容或#注释内容（MySQL特有)(– 后面的注释需要先空一格子，否则报错)·多行注释：&#x2F;*星号 内容 星号*&#x2F; MySql的基本操作：1mysql -uroot -p1234//在控制台输入 123456789101112131415161718show databases;//查询所有的数据库CREATE DATABASE IF NOT EXISTS 数据库名称；//创建数据库（判断，如果不存在则创建)create database db1//创建数据库，不能创建同名的数据库DROP DATABASE IF EXISTS 数据库名称 //删除数据库(判断，如果存在则删除)drop database da1//删除数据库use db1;//使用数据库select database();//查看使用的数据库show tables;//显示所有的表desc 表名；//查询表的结构；create table 表名(变量名 类型，.....,.....,.....//最后不要加，);//创建表drop table 表名;//删除表drop table if exists 表名；删除表时判断表是否存在 删除操作：12345678910修改表名alter table 表名 rename to 新表名；添加一列alter table 表名 add 列名 数据类型；修改数据类型alter table 表名 modify 列名 新的数据类型；修改列名和数据类型alter table 表名 change 列名 新列名 新的数据类型删除列alter table 表名 drop 列名； MySql数据的基本类型： 添加数据：12345671.给指定列添加数据insert into 表名(列名1，列名2,...)values(值1.值2，..); 2.给全部列添加数据INSERT INTO 表名VALUES（值1，值2，..）3.批量添加数据INSERT INTO 表名（列名1，列名2，.）VALUES（值1，值2，），（值1，值2，.），（值1，值2，.）INSERT INTO 表名 VALUES（值1，值2...），（值1，值2，.），（值1，值2，..）.. 修改数据：121.修改表数据UPDATE 表名 SET 列名1 = 值1，列名2 = 值2，[where条件]//如果没有加where,则表中的所有数据都会被修改 删除语法：121.删除数据DELETE FROM 表名WHERE [where条件]//如果没有加whee,则表中的所有数据都会被删除 查询:1234567891.查询多个字段SELECT 字段列表 FROM 表名：SELECT*FROM 表名：--查询所有数据-- 查询去除重复记录select distinct 字段列表 from 表名;-- 起别名AS: AS 也可以忽略，但是列名和别名之间必须空一格select name,math as 数学成绩,english as 英语成绩 from stu; 条件查询：1select 字段列表 from 表名 where 条件列表； 条件： 12345678910111213141516171819202122232425262728293031323334353637 -- 年龄大于20select *from stu WHERE age &gt; 20; -- 年龄大于20等于20select *from stu WHERE age &gt;= 20; -- -3.查询年龄大于等于20岁并且年龄小于等于30岁的学员信息select *from stu WHERE age &gt;= 20 &amp;&amp; age&lt;= 30;select *from stu WHERE age &gt;= 20 and age&lt;= 30;select *from stu WHERE age BETWEEN 20 and 30; -- 查询入学日期在&#x27;1998-09-01&#x27;到&#x27;1999-09-01&#x27;的信息 select *FROM stu where hire_date BETWEEN &#x27;1998-09-01&#x27; AND&#x27;1999-09-01&#x27;; -- 5.香询年龄等于18岁的学员信息select *from stu WHERE age = 18;-- 6.查询年龄不等于18岁的学员信息select *from stu WHERE age != 18;select *from stu WHERE age &lt;&gt; 18;-- 7：查询年龄等于18岁或者年龄等于20岁或者年龄等于22岁的学员信息select *from stu WHERE age = 18 or age = 20 or age = 22;select *from stu WHERE age in (18,20,22);-- 8：查询英语成绩为nul1的学员信息-- 注意：null 值得比较不能使用= !=，要使用is，is not;select *from stu WHERE english = null;-- 不可以select *from stu WHERE english is null;select *from stu WHERE english is not null;-- 模糊查询：/*通配符：（1）：代表单个任意字符（2）：%代表任意个数字符*/-- 1。查询姓&#x27;马&#x27;的学员信息select *from stu WHERE name like &#x27;马%&#x27;;-- 查询第二字是花的select *from stu WHERE name like &#x27;_花%&#x27;;-- 查询名字中包含&#x27;德&#x27;的信息select *from stu WHERE name like &#x27;%德%&#x27;; 分组查询：1234567891011SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1[排序方式1]，排序字段名2 [排序方式2]...;排序方式：·ASC：升序排列（默认值）·DESC:降序排列-- 1查询学生信息，按照年龄升序排列select *from stu ORDER BY age ASC;-- 2.香询学生信息，按照数学成绩降序排列select *from stu ORDER BY math desc;-- 3.查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序非列select *from stu ORDER BY math desc,english asc; 分组查询：聚合函数的分类： 函数名 功能 count（列名） 统计数量（一般选用不为null的列） max（列名） 最大值 min（列名） 最小值 sum(列名) 求和 avg（列名） 平均值 1234567891011121·统计班级共有多少个学生select count(id) from stu;-- count统计数不能为null; 2．查询数学成绩的最高分select max(math) from stu;03.查询数学成绩的最低分select min(math) from stu;4查询效学成绩的总分select max(math) from stu;5，查询数学成绩的平均分select sum(math) from stu;6，查询英语成绩的最低分select min(english) from stu;-- null值不参与聚合函数的运算 分组查询语法：123456789101112131415161.分组查询语法SELECT 字段列表FROM 表名[WHERE 分组前条件限定]GROUP BY分组字段名[HAVING分组后条件过滤]注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义where和having区别：- 执行时机不一样：where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。- 可判断的条件不一样：where不能对聚合函数进行判断，having可以执行顺序 where &gt; 聚合函数 &gt;having-- 1.查询男同学和女间学各自的数学平均分select sex,avg(math)from stu GROUP BY sex;-- 2。查询男同学和女同学各自的数学平均分，以及各自人数select sex,count(sex),avg(math)from stu GROUP BY sex;select sex,count(*),avg(math)from stu GROUP BY sex;-- 3.查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组select sex,count(*),avg(math)from stu where math &gt;70 GROUP BY sex;- 4．查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2select sex,count(*),avg(math)from stu where math &gt;70 GROUP BY sex having count(*)&gt;2; 分页查询：123456789101112131415/*分页查询：SELECT 字段列表 FROM 表名 LIMIT起始索引,查询条目数*起始索引：从0开始 */-- 从0开始查询，查询3条数据select *from stu limit 0,3;-- 2.每页显示3条数据，查询第1页数据 select *from stu limit 0,3; -- 3：每页显示3条数据，查询第2页数据select *from stu limit 3,3;-- 4：每页显示3条数据，查询第3页数据select *from stu limit 6,3; -- 起始索引=（当前的页码 - 1）*每页显示的条数 DQL小结：1234567891011121314SELECT 字段列表FROM表名列表WHERE 条件列表GROUP BY 分组字段HAVING 分组后条件ORDER BY 排序字段LIMIT 分页限定 约束： 约束的概念 约束是作用于表中列上的规则，用于限制加入表的数据 约束的存在保证了数据库中数据的正确性、有效性和完整性 约束名称 描述 关键字 非空约束 保证列中所有的数据不能有NULL值 NOT NULL 唯一约束 保证列中所有的数各不相同 UNIQUE 主键约束 主键是一行数据的为唯一标识，要求非空且唯一 PRIMARY KEY 检查约束 保证列中的值满足某一条件 CHECK 默认约束 保存数据时，未指定值采用默认数值 DEFAULT 外键约束 外键用来土让两个表的数据之间建立链接，保证数据的一致性和完整性 FOREIGN KEY tips: MYSQL不止检查约束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 创建表时添加非空约束create table 表名(列名 数据类型 NOT NULL,...);-建完表后添加非空约束ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL删除约束alter table emp modify 字段名 数据类型；-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY auto_increment, ename VARCHAR ( 50 ) NOT NULL UNIQUE, joindata DATE NOT NULL, salary DOUBLE ( 7, 2 ) NOT NULL, bonus DOUBLE ( 7, 2 ) DEFAULT 0 );INSERT INTO emp ( id, ename, joindate, salary, bonus )VALUES ( 1, &#x27;张三&#x27;, &#x27;1999-02-02&#x27;, 2000, 9000 );ALTER TABLE emp CHANGE joindata joindate date;-- 演示主键约束：非空且唯一INSERT INTO emp ( id, ename, joindate, salary, bonus )VALUES ( NULL, &#x27;张三&#x27;, &#x27;1999-02-02&#x27;, 2000, 9000 );INSERT INTO emp ( id, ename, joindate, salary, bonus )VALUES ( 1, &#x27;张三&#x27;, &#x27;1999-02-02&#x27;, 2000, 9000 ); -- 演示非空约束INSERT INTO emp ( id, ename, joindate, salary, bonus )VALUES ( 1, NULL, &#x27;1999-02-02&#x27;, 2000, 9000 ); -- 默认约束INSERT INTO emp ( id, ename, joindate, salary)VALUES ( 3, &#x27;王英&#x27;, &#x27;1999-02-02&#x27;, 2000);INSERT INTO emp ( id, ename, joindate, salary, bonus)VALUES ( 4, &#x27;王大英&#x27;, &#x27;1999-02-02&#x27;, 2000,NULL); SELECT *from em-- 演示自动增长:auto_increment:INsERT INTo emp（ename,joindate,salary,bonus)values（赵六&#x27;,&#x27;1999-11-11&#x27;,8800,null);INSERT INTo emp(id,ename,joindate,salary,bonus)values(null,赵六2&#x27;,1999-1l-11&#x27;,8800,null);INsERTINToemp(id,ename,joindate,salary,bonus)values(null,赵六3,1999-11-11,8800,null); 外键约束：概念：外键用来土让两个表的数据之间建立链接，保证数据的一致性和完整性 语法： 添加约束： 12345678910-- 创建时添加外键约束create table 表名(列名 数据类型，...[constraint][外键名称] foreign key(外键列名) references 主表（主列名）);-- 创建完后添加外键约束alter table 表名 add constraint 外键名称 foreign key(外键字段名称) references 主表名称(主表列名称)；-- 删除约束alter table 表名 drop foreign key(外键名称)； 123456789101112131415161718192021222324252627282930create table dept( id int not null PRIMARY KEY, dep_name varchar(20), addr varchar(20) );insert into dept(id,dep_name,addr)VALUES(1,&#x27;销售部&#x27;,&#x27;上海&#x27;);insert into dept(id,dep_name,addr)VALUES(2,&#x27;运营部&#x27;,&#x27;北京&#x27;); create table empl( id int PRIMARY key auto_increment, name varchar(20), age int , dep_id int, -- 添加外键 dep_id,关联 dept 表的id主键CONSTRAINT fk_empl_dept foreign key(dep_id) REFERENCES dept(id) );insert into empl(id,name,age,dep_id)VALUES(1,&#x27;塔0&#x27;,10,1);insert into empl(id,name,age,dep_id)VALUES(2,&#x27;塔2&#x27;,14,1);insert into empl(id,name,age,dep_id)VALUES(3,&#x27;塔2&#x27;,12,2);insert into empl(id,name,age,dep_id)VALUES(4,&#x27;塔3&#x27;,11,2);select *from empl;select *from dept;drop table dept;drop table empl; -- 删除外键alter table empl drop foreign key fk_empl_dept;-- 建表以后添加外键alter table empl add constraint fk_empl_dept foreign key(dep_id) REFERENCES dept(id); 数据库设计：表关系 一对一： 人和身份证 ：实现方式：在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE) 一对多：部门和员工。一个部门对应多个员工，一个员工对应多个部门 ·在多的一方建立外键关联一的一方主键 多对多：商品和订单。一个订单包含多个商品，一个商品对应多个订单· 实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 多表查询： ·笛卡尔积：取A，B集合所有组合情况 ·多表查询：从多张表查询数据 连击查询 内连接：相当于查询A，B交集数据 外连接： 左外连接：相当于查询A表的所有数据和交集部分数据 右外连接：相当于查询B表所有的数据和交集部分数据 子查询 内连接：1.内连接 查询语法 1234-- 隐式内连接SELECT 字段列表 FROM 表1，表2...WHERE条件；-- 显示内连接SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件； 外连接：1.外连接查询语法 123456789101112131415161718192021222324-- 左外连接select 字段列表 from 表1 left [outer]join 表2 on 条件；-- 右外连接select 字段列表 from 表1 right [outer]join 表2 on 条件；-- 多表查询select *from emp, dept;-- 笛卡尔积：取A，B两个集合所有的组合情况-- 消除无效数据select *from emp, dept where emp.dep_id = dept.did;-- 查询emp 的name,gender,dept表的dnameselect emp.ename,emp.,dept.addr form emp,dept where emp.dep_id= dept.id;-- 给表起别名select t1.name,t1.gender,t2.dname from emp t1,dept t2 where t1.dep_id = t2.did;-- 显示内连接select *from emp inner join dept on emp.dep_id = dept.did; -- 左外连接 -- 查询emp表的所有数据和对应的部门信息select *from emp left join dept on emp.dep_id = dept.did; -- 右外连接 -- 查询dept表的所有数据和对应的员工信息 select *from emp right join dept on emp.dep_id = dept.did; 子查询：1234567891011子查询1.子查询根据查询结果不同，作用不同：单行单列：作为条件值，使用 =！=&gt;&lt;等进行条件判断SELECT 字段列表 FROM 表WHERE 字段名 =（子查询）：多行单列：作为条件值，使用in等关键字进行条件判断SELEGT 字段列表 FROM 表 WHERE 字段名 in（子查询）：多行多列：作为虚拟表SELECT 字段列表 FROM（子查询）WHERE 条件： 练习：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/*分析：1.员工编号，员工姓名，工资在emp表2.职务名称，职务描述在job表3.job职务表和emp员工表是一对多的关系emp.job_id = job.id*/-- 隐式内连接select emp.id,emp.ename,emp.salary,job.jname,job.description from emp,job where emp.job_id = job.id;-- 显示内连接select emp.id,emp.ename,emp.salary,job.jname,job.description from emp inner join job on emp.job_id = job.id;-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置/*1.员工编号，员工姓名，工资在emp表2.职务名称，职务描述在job表3.job职务表和emp员工表是一对多的关系emp.job_id = job.id4.4.部门名称，部门位置来自于部门表dept5.dept和emp一对多关系dept.id=emp.dept_id*/-- 隐式内连接select emp.id,emp.ename,emp.salary,job.jname,job.description,dept.dname,dept.loc from emp,job,dept where emp.job_id = job.id and dept.id = emp.dept_id;-- 显示内连接select emp.id,emp.ename,emp.salary,job.jname,job.description,dept.dname,dept.loc from emp inner join job on emp.job_id = job.idinner join dept on dept.id = emp.dept_id;-- 3.查询员工姓名，工资，工资等级/*分析：1：员工姓名，工资信息在emp员工表中2.工资等级信息在salarygrade 工资等级表中3. emp.salary &gt;= salarygrade.losalary and emp.salary&lt;= salarygrade.hisalary*/select emp.ename,emp.salary,t2.grade from emp,salarygrade t2 where emp.salary &gt;= t2.losalary and emp.salary&lt;= t2.hisalary-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级/*1.员工编号，员工姓名，工资在emp表2.职务名称，职务描述在job表3.job职务表和emp员工表是一对多的关系emp.job_id = job.id4.部门名称，部门位置来自于部门表dept5.dept和emp一对多关系dept.id=emp.dept_id6.工资等级信息在salarygrade 工资等级表中7. emp.salary &gt;= salarygrade.losalary and emp.salary&lt;= salarygrade.hisalary*/select emp.id,emp.ename,emp.salary,job.jname,job.description,dept.dname,dept.loc,t2.grade from emp inner join job on emp.job_id = job.idinner join dept on dept.id = emp.dept_idinner join salarygrade t2 on emp.salary BETWEEN t2.losalary and t2.hisalary;-- 5.查询出部门编号、部门名称、部门位置、部门人数/*1.员工编号，员工姓名，工资在emp表2.部门人数：在emp表中按照deot_id进行分组，然后count()*/select *from dept;select dept_id,count(*) from emp GROUP BY dept_id;select dept.id,dept.dname,dept.loc,t1.count from dept,(select dept_id,count(*) count from emp GROUP BY dept_id ) t1 where dept.id = t1.dept_id; 事务： 数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败 事务是一个不可分割的工作逻辑单元 事务四大特征： 原子性（Atomicity）：事务是不可分割的最小操作单位，要么同时成功，要么同时失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（lsolation）多个事务之间，操作的可见性 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 123456789101112131415161718192021222324252627282930313233343536373839404142DROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account( id int PRIMARY KEY auto_increment, name varchar(10), money double(10,2));-- 添加数据INSERT INTO account(name,money) values(&#x27;张三&#x27;,1000),(&#x27;李四&#x27;,1000);UPDATE account set money = 1000;select * from account;-- 开启事务BEGIN;-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#x27;李四&#x27;;-- 出现异常了...-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#x27;张三&#x27;;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 查看事务的默认提交方式SELECT @@autocommit;-- 1 自动提交 0 手动提交-- 修改事务提交方式set @@autocommit = 0; JDBC:JDBC概念： JDBC就是使用Java语言操作关系型数据库的一套API ·全称：（Java DataBase Connectivity）Java数据库连接 JDBC本质：：官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口：各个数据库厂商去实现这套接口提供数据库驱动ar包 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类 JDBC的好处： 各数据库厂商使用相同的接口Java代码不需要针对不同数据库分别开发 可随时替换底层数据库，访问数据库的Java代码基本不变 连接数据库步骤：12345678910111213141516171819200.创建工程，导入驱动jar包//1. 注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//2. 获取连接String url = &quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;;String username = &quot;root&quot;;String password = &quot;1234&quot;;Connection conn = DriverManager.getConnection(url, username, password);//3. 定义sqlString sql = &quot;update account set money = 2000 where id = 1&quot;;//4. 获取执行sql的对象 StatementStatement stmt = conn.createStatement();//5. 执行sqlint count = stmt.executeUpdate(sql);//受影响的行数//6. 处理结果//System.out.println(count);//7. 释放资源stmt.close();conn.close(); JDBC API 详解：DriverManager DriverManager(驱动管理类)作用： 1.注册驱动 121.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 提示： MySQL5之后的驱动包，可以省略注册驱动的步骤 自动加载jar包中META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类 2.获取数据库连接 12static Connection getconnection(string url, string user, string password) 参数 url:连接路径 12345语法：jdbc：mysql://ip地址（域名）：端口号/数据库名称？参数键值对1 &amp; 参数键值对2..示例：jdbc:mysql://127.0.0.1:3306/db1细节：1.如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则ur可以简写为：jdbc:mysql:///数据库名称？参数键值对2.配置useSSL=false参数，禁用安全连接方式，解决警告提示 connection: Connection（数据库连接对象）作用：1.获取执行SQL的对象2.管理事务 1.获取执行的SQL的的对象 普通执行SQL对象 1Statement createStatement() 预编译SQL的执行SQL对象：防止SQL注入 1PreparedStatement prepareStatement(sql) 执行存储的过程的的对象 1CallableStatement prepareCall(sql) 2.事务管理： MySQl 事务管理： 1234开启事务：BEGIN;/START TRANSACTION；提交事务：COMMIT：回滚事务：ROLLBACKMySQL默认自动提交事务 JDBC事务管理：Connection接口中定义了三个对应的方法 123开后事务：setAutoCommit(booleanautoCommit)：true为自动提交事务：false为手动提交事务，即为开启事务提交事务：commit()回滚事务：rollback() 具体代码时实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * JDBC API 详解：Connection */public class JDBCDemo3_Connection &#123; public static void main(String[] args) throws Exception &#123; //1. 注册驱动 //Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql1 = &quot;update account set money = 3000 where id = 1&quot;; String sql2 = &quot;update account set money = 3000 where id = 2&quot;; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); try &#123; // ============开启事务========== conn.setAutoCommit(false); //5. 执行sql int count1 = stmt.executeUpdate(sql1);//受影响的行数 //6. 处理结果 System.out.println(count1); int i = 3/0; //5. 执行sql int count2 = stmt.executeUpdate(sql2);//受影响的行数 //6. 处理结果 System.out.println(count2); // ============提交事务========== //程序运行到此处，说明没有出现任何问题，则需求提交事务 conn.commit(); &#125; catch (Exception e) &#123; // ============回滚事务========== //程序在出现异常时会执行到这个地方，此时就需要回滚事务 conn.rollback(); e.printStackTrace(); &#125; //7. 释放资源 stmt.close(); conn.close(); &#125;&#125; Statement作用： 执行SQL语句 1234int executeUpdate(sql)：执行DML、DDL语句返回值：（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0ResultSet executeQuerysql）：执行DQL语句返回值：ResultSet结果集对象 代码实现： 123456789101112131415161718192021222324252627282930/** * 执行DML语句 * @throws Exception */@Testpublic void testDML() throws Exception &#123; //1. 注册驱动 //Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = &quot;update account set money = 3000 where id = 1&quot;; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //5. 执行sql int count = stmt.executeUpdate(sql);//执行完DML语句，受影响的行数 //6. 处理结果 //System.out.println(count); if(count &gt; 0)&#123; System.out.println(&quot;修改成功~&quot;); &#125;else&#123; System.out.println(&quot;修改失败~&quot;); &#125; //7. 释放资源 stmt.close(); conn.close();&#125; 执行DDL语句 1234567891011121314151617181920212223242526/** * 执行DDL语句 * @throws Exception */@Testpublic void testDDL() throws Exception &#123; //1. 注册驱动 //Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = &quot;drop database db2&quot;; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //5. 执行sql int count = stmt.executeUpdate(sql);//执行完DDL语句，可能是0 //6. 处理结果 System.out.println(count); //7. 释放资源 stmt.close(); conn.close();&#125; 注意： 以后开发很少使用java代码操作DDL语句 ResultSet ResultSet(结果集对象)作用 1.封装DQL查询语句的结果 而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下： 1ResultSet executeQuery(sql)：执行DQL 语句，返回 ResultSet 对象 那么我们就需要从 ResultSet 对象中获取我们想要的数据。ResultSet 对象提供了操作查询结果数据的方法，如下： boolean next() 将光标从当前位置向前移动一行 判断当前行是否为有效行 方法返回值说明： true ： 有效航，当前行有数据 false ： 无效行，当前行没有数据 xxx getXxx(参数)：获取数据 xxx : 数据类型；如： int getInt(参数) ；String getString(参数) 参数 int类型的参数：列的编号，从1开始 String类型的参数： 列的名称 如下图为执行SQL语句后的结果 一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 next() 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 getInt(&quot;id&quot;) 获取当前行id字段的值，也可以通过 getString(&quot;name&quot;) 获取当前行name字段的值。如果想获取下一行的数据，继续调用 next() 方法，以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 执行DQL * @throws Exception */@Testpublic void testResultSet() throws Exception &#123; //1. 注册驱动 //Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = &quot;select * from account&quot;; //4. 获取statement对象 Statement stmt = conn.createStatement(); //5. 执行sql ResultSet rs = stmt.executeQuery(sql); //6. 处理结果， 遍历rs中的所有数据 /* // 6.1 光标向下移动一行，并且判断当前行是否有数据 while (rs.next())&#123; //6.2 获取数据 getXxx() int id = rs.getInt(1); String name = rs.getString(2); double money = rs.getDouble(3); System.out.println(id); System.out.println(name); System.out.println(money); System.out.println(&quot;--------------&quot;); &#125;*/ // 6.1 光标向下移动一行，并且判断当前行是否有数据 while (rs.next())&#123; //6.2 获取数据 getXxx() int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); double money = rs.getDouble(&quot;money&quot;); System.out.println(id); System.out.println(name); System.out.println(money); System.out.println(&quot;--------------&quot;); &#125; //7. 释放资源 rs.close(); stmt.close(); conn.close();&#125; 案列：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中 * 1. 定义实体类Account * 2. 查询数据，封装到Account对象中 * 3. 将Account对象存入ArrayList集合中 */@Testpublic void testResultSet2() throws Exception &#123; //1. 注册驱动 //Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = &quot;select * from account&quot;; //4. 获取statement对象 Statement stmt = conn.createStatement(); //5. 执行sql ResultSet rs = stmt.executeQuery(sql); // 创建集合 List&lt;Account&gt; list = new ArrayList&lt;&gt;(); // 6.1 光标向下移动一行，并且判断当前行是否有数据 while (rs.next())&#123; Account account = new Account(); //6.2 获取数据 getXxx() int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); double money = rs.getDouble(&quot;money&quot;); //赋值 account.setId(id); account.setName(name); account.setMoney(money); // 存入集合 list.add(account); &#125; System.out.println(list); //7. 释放资源 rs.close(); stmt.close(); conn.close();&#125; PreparedStatement： PreparedStatement作用： 预编译SQL语句并执行：预防SQL注入问题 对上面的作用中SQL注入问题大家肯定不理解。那我们先对SQL注入进行说明. SQL注入 SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。 在今天资料下的 day03-JDBC\\资料\\2. sql注入演示 中修改 application.properties 文件中的用户名和密码，文件内容如下： 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=1234 在MySQL中创建名为 test 的数据库 1create database test; 在命令提示符中运行今天资料下的 day03-JDBC\\资料\\2. sql注入演示\\sql.jar 这个jar包 此时我们就能在数据库中看到user表 接下来在浏览器的地址栏输入 localhost:8080/login.html 就能看到如下页面 我们就可以在如上图中输入用户名和密码进行登陆。用户名和密码输入正确就登陆成功，跳转到首页。用户名和密码输入错误则给出错误提示，如下图 但是我可以通过输入一些特殊的字符登陆到首页。 用户名随意写，密码写成 &#39; or &#39;1&#39; =&#39;1 这就是SQL注入漏洞，也是很危险的。当然现在市面上的系统都不会存在这种问题了，所以大家也不要尝试用这种方式去试其他的系统。 那么该如何解决呢？这里就可以将SQL执行对象 Statement 换成 PreparedStatement 对象。 PreparedStatement概述 PreparedStatement作用： 预编译SQL语句并执行：预防SQL注入问题 获取 PreparedStatement 对象 1234// SQL语句中的参数值，使用？占位符替代String sql = &quot;select * from user where username = ? and password = ?&quot;;// 通过Connection对象获取，并传入对应的sql语句PreparedStatement pstmt = conn.prepareStatement(sql); 设置参数值 上面的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ? 的值。 PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值 Xxx：数据类型 ； 如 setInt (参数1，参数2) 参数： 参数1： ？的位置编号，从1 开始 参数2： ？的值 执行SQL语句 executeUpdate(); 执行DDL语句和DML语句 executeQuery(); 执行DQL语句 &#x3D;&#x3D;注意：&#x3D;&#x3D; 调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。 使用PreparedStatement改进1234567891011121314151617181920212223242526272829303132 @Testpublic void testPreparedStatement() throws Exception &#123; //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入 用户名和密码 String name = &quot;zhangsan&quot;; String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;; // 定义sql String sql = &quot;select * from tb_user where username = ? and password = ?&quot;; // 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // 设置？的值 pstmt.setString(1,name); pstmt.setString(2,pwd); // 执行sql ResultSet rs = pstmt.executeQuery(); // 判断登录是否成功 if(rs.next())&#123; System.out.println(&quot;登录成功~&quot;); &#125;else&#123; System.out.println(&quot;登录失败~&quot;); &#125; //7. 释放资源 rs.close(); pstmt.close(); conn.close();&#125; 执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下： 1select * from tb_user where username = &#x27;sjdljfld&#x27; and password = &#x27;\\&#x27;or \\&#x27;1\\&#x27; = \\&#x27;1&#x27; PreparedStatement原理： PreparedStatement 好处： 预编译SQL，性能更高 防止SQL注入：&#x3D;&#x3D;将敏感字符进行转义&#x3D;&#x3D; Java代码操作数据库流程如图所示： 将sql语句发送到MySQL服务器端 MySQL服务端会对sql语句进行如下操作 检查SQL语句 检查SQL语句的语法是否正确。 编译SQL语句。将SQL语句编译成可执行的函数。 检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。 执行SQL语句 接下来我们通过查询日志来看一下原理。 开启预编译功能 在代码中编写url时需要加上以下参数。而我们之前根本就没有开启预编译功能，只是解决了SQL注入漏洞。 1useServerPrepStmts=true 配置MySQL执行日志（重启mysql服务后生效） 在mysql配置文件（my.ini）中添加如下配置 123456log-output=FILEgeneral-log=1general_log_file=&quot;D:\\mysql.log&quot;slow-query-log=1slow_query_log_file=&quot;D:\\mysql_slow.log&quot;long_query_time=2 java测试代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /** * PreparedStatement原理 * @throws Exception */@Testpublic void testPreparedStatement2() throws Exception &#123; //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 // useServerPrepStmts=true 参数开启预编译功能 String url = &quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入 用户名和密码 String name = &quot;zhangsan&quot;; String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;; // 定义sql String sql = &quot;select * from tb_user where username = ? and password = ?&quot;; // 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); Thread.sleep(10000); // 设置？的值 pstmt.setString(1,name); pstmt.setString(2,pwd); ResultSet rs = null; // 执行sql rs = pstmt.executeQuery(); // 设置？的值 pstmt.setString(1,&quot;aaa&quot;); pstmt.setString(2,&quot;bbb&quot;); // 执行sql rs = pstmt.executeQuery(); // 判断登录是否成功 if(rs.next())&#123; System.out.println(&quot;登录成功~&quot;); &#125;else&#123; System.out.println(&quot;登录失败~&quot;); &#125; //7. 释放资源 rs.close(); pstmt.close(); conn.close();&#125; 执行SQL语句，查看 D:\\mysql.log 日志如下: 上图中第三行中的 Prepare 是对SQL语句进行预编译。第四行和第五行是执行了两次SQL语句，而第二次执行前并没有对SQL进行预编译。 &#x3D;&#x3D;小结：&#x3D;&#x3D; 在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时） 执行时就不用再进行这些步骤了，速度更快 如果sql模板一样，则只需要进行一次检查、编译 数据连接池：数据库连接池简介 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个； 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏 好处 资源重用 提升系统响应速度 避免数据库连接遗漏 之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。 而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图 连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。 数据库连接池实现 标准接口：&#x3D;&#x3D;DataSource&#x3D;&#x3D; 官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能： 1Connection getConnection() 那么以后就不需要通过 DriverManager 对象获取 Connection 对象，而是通过连接池（DataSource）获取 Connection 对象。 常见的数据库连接池 DBCP C3P0 Druid 我们现在使用更多的是Druid，它的性能比其他两个会好一些。 Druid（德鲁伊） Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是Java语言最好的数据库连接池之一 riud使用 导入jar包 druid-1.1.12.jar 定义配置文件 加载配置文件 获取数据库连接池对象 获取连接 现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件 项目结构如下： 使用druid的代码如下： 1234567891011121314151617181920212223242526272829package druid;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.FileInputStream;import java.sql.Connection;import java.util.Properties;/** *druid数据库连接池的连接 */public class Druid &#123; public static void main(String[] args) throws Exception &#123; //1.导入jar包 //2.定义配置文件 //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(&quot;src/druid.properties&quot;)); //4.获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //获取Connection Connection connection = dataSource.getConnection(); System.out.println(connection); //System.out.println(System.getProperty(&quot;user.dir&quot;));获取当前项目的路径 &#125;&#125; JDBC练习：需求完成商品品牌数据的增删改查操作 查询：查询所有数据 添加：添加品牌 修改：根据id修改 删除：根据id删除 案例实现环境准备数据库表 tb_brand 12345678910111213141516171819202122-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1); 在pojo包下实体类 Brand 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 品牌 * alt + 鼠标左键：整列编辑 * 在实体类中，基本数据类型建议使用其对应的包装类型 */public class Brand &#123; // id 主键 private Integer id; // 品牌名称 private String brandName; // 企业名称 private String companyName; // 排序字段 private Integer ordered; // 描述信息 private String description; // 状态：0：禁用 1：启用 private Integer status; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getBrandName() &#123; return brandName; &#125; public void setBrandName(String brandName) &#123; this.brandName = brandName; &#125; public String getCompanyName() &#123; return companyName; &#125; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public Integer getOrdered() &#123; return ordered; &#125; public void setOrdered(Integer ordered) &#123; this.ordered = ordered; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; @Override public String toString() &#123; return &quot;Brand&#123;&quot; + &quot;id=&quot; + id + &quot;, brandName=&#x27;&quot; + brandName + &#x27;\\&#x27;&#x27; + &quot;, companyName=&#x27;&quot; + companyName + &#x27;\\&#x27;&#x27; + &quot;, ordered=&quot; + ordered + &quot;, description=&#x27;&quot; + description + &#x27;\\&#x27;&#x27; + &quot;, status=&quot; + status + &#x27;&#125;&#x27;; &#125;&#125; 查询所有： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * 查询所有 * 1. SQL：select * from tb_brand; * 2. 参数：不需要 * 3. 结果：List&lt;Brand&gt; */@Testpublic void testSelectAll() throws Exception &#123; //1. 获取Connection //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;)); //4. 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取数据库连接 Connection Connection conn = dataSource.getConnection(); //2. 定义SQL String sql = &quot;select * from tb_brand;&quot;; //3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); //4. 设置参数 //5. 执行SQL ResultSet rs = pstmt.executeQuery(); //6. 处理结果 List&lt;Brand&gt; 封装Brand对象，装载List集合 Brand brand = null; List&lt;Brand&gt; brands = new ArrayList&lt;&gt;(); while (rs.next())&#123; //获取数据 int id = rs.getInt(&quot;id&quot;); String brandName = rs.getString(&quot;brand_name&quot;); String companyName = rs.getString(&quot;company_name&quot;); int ordered = rs.getInt(&quot;ordered&quot;); String description = rs.getString(&quot;description&quot;); int status = rs.getInt(&quot;status&quot;); //封装Brand对象 brand = new Brand(); brand.setId(id); brand.setBrandName(brandName); brand.setCompanyName(companyName); brand.setOrdered(ordered); brand.setDescription(description); brand.setStatus(status); //装载集合 brands.add(brand); &#125; System.out.println(brands); //7. 释放资源 rs.close(); pstmt.close(); conn.close();&#125; 添加数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /** * 添加 * 1. SQL：insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?); * 2. 参数：需要，除了id之外的所有参数信息 * 3. 结果：boolean */ @Test public void testadd() throws Exception &#123; // 接收页面提交的参数 String brandName = &quot;香飘飘&quot;; String companyName = &quot;香飘飘&quot;; int ordered = 1; String description = &quot;绕地球一圈&quot;; int status = 1; //3.加载配置文件 Properties pops = new Properties(); pops.load(new FileInputStream(&quot;src/druid.properties&quot;)); //4.获取连接池的对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(pops); //5.获取数据库连接 Connection conn = dataSource.getConnection(); //6.定义sql //String sql = &quot;select * from tb_brand&quot;; String sql = &quot;insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);&quot;; //获取statement对象 PreparedStatement psmt = conn.prepareStatement(sql); //7.设置参数 psmt.setString(1, brandName); psmt.setString(2, companyName); psmt.setInt(3, ordered); psmt.setString(4, description); psmt.setInt(5, status); //8.执行sql int count = psmt.executeUpdate(); //处理结果 System.out.println(count &gt; 0); //释放资源 psmt.close(); conn.close(); &#125;&#125; 修改数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 修改 * 1. SQL： update tb_brand set brand_name = ?, company_name= ?, ordered = ?, description = ?, status = ? where id = ? * 2. 参数：需要，所有数据 * 3. 结果：boolean */ @Test public void testupdate() throws Exception &#123; // 接收页面提交的参数 // 接收页面提交的参数 String brandName = &quot;香飘飘&quot;; String companyName = &quot;香飘飘&quot;; int ordered = 1000; String description = &quot;绕地球三圈&quot;; int status = 1; int id = 4; //3.加载配置文件 Properties pops = new Properties(); pops.load(new FileInputStream(&quot;src/druid.properties&quot;)); //4.获取连接池的对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(pops); //5.获取数据库连接 Connection conn = dataSource.getConnection(); //6.定义sql //String sql = &quot;select * from tb_brand&quot;; String sql = &quot; update tb_brand\\n&quot; + &quot; set brand_name = ?,\\n&quot; + &quot; company_name= ?,\\n&quot; + &quot; ordered = ?,\\n&quot; + &quot; description = ?,\\n&quot; + &quot; status = ?\\n&quot; + &quot; where id = ?&quot;; //获取statement对象 PreparedStatement psmt = conn.prepareStatement(sql); //7.设置参数 psmt.setString(1, brandName); psmt.setString(2, companyName); psmt.setInt(3, ordered); psmt.setString(4, description); psmt.setInt(5, status); psmt.setInt(6,id); //8.执行sql int count = psmt.executeUpdate(); //处理结果 System.out.println(count &gt; 0); //释放资源 psmt.close(); conn.close(); &#125; 删除数据： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 删除 * 1. SQL： delete from tb_brand where id = ? * 2. 参数：需要，id * 3. 结果：boolean */ @Test public void testupdelete() throws Exception &#123; // 接收页面提交的参数 int id = 4; //1.导入jar包 //2.定义配置文件 //3.加载配置文件 Properties pops = new Properties(); pops.load(new FileInputStream(&quot;src/druid.properties&quot;)); //4.获取连接池的对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(pops); //5.获取数据库连接 Connection conn = dataSource.getConnection(); //6.定义sql //String sql = &quot;select * from tb_brand&quot;; String sql = &quot;delete from tb_brand where id = ?&quot;; //获取statement对象 PreparedStatement psmt = conn.prepareStatement(sql); //7.设置参数 psmt.setInt(1,id); //8.执行sql int count = psmt.executeUpdate(); //处理结果 System.out.println(count &gt; 0); //释放资源 psmt.close(); conn.close(); &#125; Maven&amp;MyBatis目标 能够使用Maven进行项目的管理 能够完成Mybatis代理方式查询数据 能够理解Mybatis核心配置文件的配置 1，MavenMaven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构 提供了一套标准化的构建流程（编译，测试，打包，发布……） 提供了一套依赖管理机制 标准化的项目结构： 项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便，如下图:前两个是以后开发经常使用的开发工具 而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。 标准化的构建流程： 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 依赖管理： 依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包（当前之前是老师已经下载好提供给大家了），复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示 而Maven使用标准的 &#x3D;&#x3D;坐标&#x3D;&#x3D; 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。 如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。 市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比 1.1 Maven简介 &#x3D;&#x3D;Apache Maven&#x3D;&#x3D; 是一个项目管理和构建&#x3D;&#x3D;工具&#x3D;&#x3D;，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。 官网 ：http://maven.apache.org/ 通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。 1.1.1 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 插件(Plugin) 如上图所示就是Maven的模型，而我们先看紫色框框起来的部分，他就是用来完成 标准化构建流程 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。 上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目： 依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，如下图所示 上述Maven模型图中还有一部分是仓库。如何理解仓库呢？ 1.1.2 仓库大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。 仓库分类： 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 地址： https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 今天我们只学习远程仓库的使用，并不会搭建。 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包： 如果有，则在项目直接引用; 如果没有，则去中央仓库中下载对应的jar包到本地仓库。 如果还可以搭建远程仓库，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库 1.2 Maven安装配置 解压 apache-maven-3.6.1.rar 既安装完成 建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 D:\\software 下。 解压缩后的目录结构如下： bin目录 ： 存放的是可执行命令。mvn 命令重点关注。 conf目录 ：存放Maven的配置文件。settings.xml 配置文件后期需要修改。 lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。 配置环境变量 MAVEN_HOME 为安装路径的bin目录 此电脑 右键 –&gt; 高级系统设置 –&gt; 高级 –&gt; 环境变量 在系统变量处新建一个变量 MAVEN_HOME 在 Path 中进行配置 打开命令提示符进行验证，出现如图所示表示安装成功 配置本地仓库 修改 conf&#x2F;settings.xml 中的 为一个指定目录作为本地仓库，用来存储jar包。 配置阿里云私服 中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 修改 conf&#x2F;settings.xml 中的 标签，为其添加如下子标签： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 1.3 Maven基本使用1.3.1 Maven 常用命令 compile ：编译 clean：清理 test：测试 package：打包 install：安装 命令演示： 在 资料\\代码\\maven-project 提供了一个使用Maven构建的项目，项目结构如下： 而我们使用上面命令需要在磁盘上进入到项目的 pom.xml 目录下，打开命令提示符 编译命令演示： 1compile ：编译 执行上述命令可以看到： 从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件 在项目下会生成一个 target 目录 同时在项目下会出现一个 target 目录，编译后的字节码文件就放在该目录下 清理命令演示： 1mvn clean 执行上述命令可以看到 从阿里云下载清理需要的插件jar包 删除项目下的 target 目录 打包命令演示： 1mvn package 执行上述命令可以看到： 从阿里云下载打包需要的插件jar包 在项目的 terget 目录下有一个jar包（将当前项目打成的jar包） 测试命令演示： 1mvn test 该命令会执行所有的测试代码。执行上述命令效果如下 安装命令演示： 1mvn install 该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下： 1.3.2 Maven 生命周期Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven 对项目构建的生命周期划分为3套： clean ：清理工作。 default ：核心工作，例如编译，测试，打包，安装等。 site ： 产生报告，发布站点等。这套声明周期一般不会使用。 同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下： 当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test 命令，再执行 package 命令，最后执行 install 命令。 当我们执行 package （打包）命令时，它会先执行 compile 命令，再执行 test 命令，最后执行 package 命令。 默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的： 1.4 IDEA使用Maven以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。 1.4.1 IDEA配置Maven环境我们需要先在IDEA中配置Maven环境： 选择 IDEA中 File –&gt; Settings 搜索 maven 设置 IDEA 使用本地安装的 Maven，并修改配置文件路径 1.4.2 Maven 坐标详解什么是坐标？ Maven 中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D; 使用坐标来定义项目或引入项目中需要的依赖 Maven 坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目： &#x3D;&#x3D;注意：&#x3D;&#x3D; 上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 1.4.3 IDEA 创建 Maven项目 创建模块，选择Maven，点击Next 填写模块名称，坐标信息，点击finish，创建完成 创建好的项目目录结构如下： 编写 HelloWorld，并运行 1.4.4 IDEA 导入 Maven项目大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入： 选择右侧Maven面板，点击 + 号 选中对应项目的pom.xml文件，双击即可 如果没有Maven面板，选择 View –&gt; Appearance –&gt; Tool Window Bars 可以通过下图所示进行命令的操作： 配置 Maven-Helper 插件 选择 IDEA中 File –&gt; Settings 选择 Plugins 搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept 重启 IDEA 安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示： 1.5 依赖管理1.5.1 使用坐标引入jar包使用坐标引入jar包的步骤： 在项目的 pom.xml 中编写 标签 在 标签中 使用 引入坐标 定义坐标的 groupId，artifactId，version 点击刷新按钮，使坐标生效 注意： 具体的坐标我们可以到如下网站进行搜索 https://mvnrepository.com/ 快捷方式导入jar包的坐标： 每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式 在 pom.xml 中 按 alt + insert，选择 Dependency 在弹出的面板中搜索对应坐标，然后双击选中对应坐标 点击刷新按钮，使坐标生效 自动导入设置： 上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成 选择 IDEA中 File –&gt; Settings 在弹出的面板中找到 Build Tools 选择 Any changes，点击 ok 即可生效 1.5.2 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。 如下图所示给 junit 依赖通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 那么 scope 都可以有哪些取值呢？ 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile Y Y Y logback test - Y - Junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 system Y Y - 存储在本地的jar包 compile ：作用于编译环境、测试环境、运行环境。 test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值 provided ：作用于编译环境、测试环境。我们后面会学习 servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错 runtime ： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题 注意： 如果引入坐标不指定 scope 标签时，默认就是 compile 值。以后大部分jar包都是使用默认值。 2，Mybatis2.1 Mybatis概述2.1.1 Mybatis概念 MyBatis 是一款优秀的&#x3D;&#x3D;持久层框架&#x3D;&#x3D;，用于简化 JDBC 开发 MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github 官网：https://mybatis.org/mybatis-3/zh/index.html 持久层： 负责将数据到保存到数据库的那一层代码。 以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。 JavaEE三层架构：表现层、业务层、持久层 三层架构在后期会给大家进行讲解，今天先简单的了解下即可。 框架： 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 在框架的基础之上构建软件编写更加高效、规范、通用、可扩展 举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦 如下图所示有一个石膏娃娃，这个就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦 了解了什么是Mybatis后，接下来说说以前 JDBC代码 的缺点以及Mybatis又是如何解决的。 2.1.2 JDBC 缺点下面是 JDBC 代码，我们通过该代码分析都存在什么缺点： 硬编码 注册驱动、获取连接 上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。 SQL语句 上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。 操作繁琐 手动设置参数 手动封装结果集 上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。 2.1.3 Mybatis 优化 硬编码可以配置到&#x3D;&#x3D;配置文件&#x3D;&#x3D; 操作繁琐的地方mybatis都&#x3D;&#x3D;自动完成&#x3D;&#x3D; 如图所示 下图是持久层框架的使用占比。 2.2 Mybatis快速入门需求：查询user表中所有的数据 创建user表，添加数据 12345678910111213141516create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user( id int primary key auto_increment, username varchar(20), password varchar(20), gender char(1), addr varchar(30));INSERT INTO tb_user VALUES (1, &#x27;zhangsan&#x27;, &#x27;123&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);INSERT INTO tb_user VALUES (2, &#x27;李四&#x27;, &#x27;234&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;);INSERT INTO tb_user VALUES (3, &#x27;王五&#x27;, &#x27;11&#x27;, &#x27;男&#x27;, &#x27;西安&#x27;); 创建模块，导入坐标 在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加slf4j日志api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-classic依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-core依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：需要在项目的 resources 目录下创建logback的配置文件 编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题 在模块下的 resources 目录下创建mybatis的配置文件 mybatis-config.xml，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写 SQL 映射文件 –&gt; 统一管理sql语句，解决硬编码问题 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 编码 在 com.itheima.pojo 包下创建 User类 123456789public class User &#123; private int id; private String username; private String password; private String gender; private String addr; //省略了 setter 和 getter&#125; 在 com.itheima 包下编写 MybatisDemo 测试类 1234567891011121314151617public class MyBatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 解决SQL映射文件的警告提示： 在入门案例映射配置文件中存在报红的情况。问题如下： 产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。 解决方式：在Idea中配置MySQL数据库连接。 IDEA中配置MySQL数据库连接 点击IDEA右边框的 Database ，在展开的界面点击 + 选择 Data Source ，再选择 MySQL 在弹出的界面进行基本信息的填写 点击完成后就能看到如下界面 而此界面就和 navicat 工具一样可以进行数据库的操作。也可以编写SQL语句 2.3 Mapper代理开发2.3.1 Mapper代理开发概述之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下： 这里调用 selectList() 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。 通过上面的描述可以看出 Mapper 代理方式的目的： 解决原生方式中的硬编码 简化后期执行SQL Mybatis 官网也是推荐使用 Mapper 代理的方式。下图是截止官网的图片 2.3.2 使用Mapper代理要求使用Mapper代理方式，必须满足以下要求： 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图： 设置SQL映射文件的namespace属性为Mapper接口全限定名 在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 2.3.3 案例代码实现 在 com.itheima.mapper 包下创建 UserMapper接口，代码如下： 1234public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; 在 resources 下创建 com/itheima/mapper 目录，并在该目录下创建 UserMapper.xml 映射配置文件 123456789&lt;!-- namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 在 com.itheima 包下创建 MybatisDemo2 测试类，代码如下： 123456789101112131415161718192021222324/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql //3.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; &#x3D;&#x3D;注意：&#x3D;&#x3D; 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为 123456&lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt; 2.4 核心配置文件核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容 接下来我们先对里面的一些配置进行讲解。 2.4.1 多环境配置在核心配置文件的 environments 标签中其实是可以配置多个 environment ，使用 id 给每段环境起名，在 environments 中使用 default=&#39;环境id&#39; 来指定使用哪儿段配置。我们一般就配置一个 environment 即可。 1234567891011121314151617181920212223&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;= 2.4.2 类型别名在映射配置文件中的 resultType 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 类型别名(typeAliases) 可以简化这部分的书写。 首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下： 1234&lt;typeAliases&gt; &lt;!--name属性的值是实体类所在包--&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; 通过上述的配置，我们就可以简化映射配置文件中 resultType 属性值的编写 12345&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; Maven&amp;MyBatis目标 能够使用Maven进行项目的管理 能够完成Mybatis代理方式查询数据 能够理解Mybatis核心配置文件的配置 1，MavenMaven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构 提供了一套标准化的构建流程（编译，测试，打包，发布……） 提供了一套依赖管理机制 标准化的项目结构： 项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便，如下图:前两个是以后开发经常使用的开发工具 而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。 标准化的构建流程： 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 依赖管理： 依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包（当前之前是老师已经下载好提供给大家了），复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示 而Maven使用标准的 &#x3D;&#x3D;坐标&#x3D;&#x3D; 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。 如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。 市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比 1.1 Maven简介 &#x3D;&#x3D;Apache Maven&#x3D;&#x3D; 是一个项目管理和构建&#x3D;&#x3D;工具&#x3D;&#x3D;，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。 官网 ：http://maven.apache.org/ 通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。 1.1.1 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 插件(Plugin) 如上图所示就是Maven的模型，而我们先看紫色框框起来的部分，他就是用来完成 标准化构建流程 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。 上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目： 依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，如下图所示 上述Maven模型图中还有一部分是仓库。如何理解仓库呢？ 1.1.2 仓库大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。 仓库分类： 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 地址： https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 今天我们只学习远程仓库的使用，并不会搭建。 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包： 如果有，则在项目直接引用; 如果没有，则去中央仓库中下载对应的jar包到本地仓库。 如果还可以搭建远程仓库，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库 1.2 Maven安装配置 解压 apache-maven-3.6.1.rar 既安装完成 建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 D:\\software 下。 解压缩后的目录结构如下： bin目录 ： 存放的是可执行命令。mvn 命令重点关注。 conf目录 ：存放Maven的配置文件。settings.xml 配置文件后期需要修改。 lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。 配置环境变量 MAVEN_HOME 为安装路径的bin目录 此电脑 右键 –&gt; 高级系统设置 –&gt; 高级 –&gt; 环境变量 在系统变量处新建一个变量 MAVEN_HOME 在 Path 中进行配置 打开命令提示符进行验证，出现如图所示表示安装成功 配置本地仓库 修改 conf&#x2F;settings.xml 中的 为一个指定目录作为本地仓库，用来存储jar包。 配置阿里云私服 中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 修改 conf&#x2F;settings.xml 中的 标签，为其添加如下子标签： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 1.3 Maven基本使用1.3.1 Maven 常用命令 compile ：编译 clean：清理 test：测试 package：打包 install：安装 命令演示： 在 资料\\代码\\maven-project 提供了一个使用Maven构建的项目，项目结构如下： 而我们使用上面命令需要在磁盘上进入到项目的 pom.xml 目录下，打开命令提示符 编译命令演示： 1compile ：编译 执行上述命令可以看到： 从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件 在项目下会生成一个 target 目录 同时在项目下会出现一个 target 目录，编译后的字节码文件就放在该目录下 清理命令演示： 1mvn clean 执行上述命令可以看到 从阿里云下载清理需要的插件jar包 删除项目下的 target 目录 打包命令演示： 1mvn package 执行上述命令可以看到： 从阿里云下载打包需要的插件jar包 在项目的 terget 目录下有一个jar包（将当前项目打成的jar包） 测试命令演示： 1mvn test 该命令会执行所有的测试代码。执行上述命令效果如下 安装命令演示： 1mvn install 该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下： 1.3.2 Maven 生命周期Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven 对项目构建的生命周期划分为3套： clean ：清理工作。 default ：核心工作，例如编译，测试，打包，安装等。 site ： 产生报告，发布站点等。这套声明周期一般不会使用。 同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下： 当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test 命令，再执行 package 命令，最后执行 install 命令。 当我们执行 package （打包）命令时，它会先执行 compile 命令，再执行 test 命令，最后执行 package 命令。 默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的： 1.4 IDEA使用Maven以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。 1.4.1 IDEA配置Maven环境我们需要先在IDEA中配置Maven环境： 选择 IDEA中 File –&gt; Settings 搜索 maven 设置 IDEA 使用本地安装的 Maven，并修改配置文件路径 1.4.2 Maven 坐标详解什么是坐标？ Maven 中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D; 使用坐标来定义项目或引入项目中需要的依赖 Maven 坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目： &#x3D;&#x3D;注意：&#x3D;&#x3D; 上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 1.4.3 IDEA 创建 Maven项目 创建模块，选择Maven，点击Next 填写模块名称，坐标信息，点击finish，创建完成 创建好的项目目录结构如下： 编写 HelloWorld，并运行 1.4.4 IDEA 导入 Maven项目大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入： 选择右侧Maven面板，点击 + 号 选中对应项目的pom.xml文件，双击即可 如果没有Maven面板，选择 View –&gt; Appearance –&gt; Tool Window Bars 可以通过下图所示进行命令的操作： 配置 Maven-Helper 插件 选择 IDEA中 File –&gt; Settings 选择 Plugins 搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept 重启 IDEA 安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示： 1.5 依赖管理1.5.1 使用坐标引入jar包使用坐标引入jar包的步骤： 在项目的 pom.xml 中编写 标签 在 标签中 使用 引入坐标 定义坐标的 groupId，artifactId，version 点击刷新按钮，使坐标生效 注意： 具体的坐标我们可以到如下网站进行搜索 https://mvnrepository.com/ 快捷方式导入jar包的坐标： 每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式 在 pom.xml 中 按 alt + insert，选择 Dependency 在弹出的面板中搜索对应坐标，然后双击选中对应坐标 点击刷新按钮，使坐标生效 自动导入设置： 上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成 选择 IDEA中 File –&gt; Settings 在弹出的面板中找到 Build Tools 选择 Any changes，点击 ok 即可生效 1.5.2 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。 如下图所示给 junit 依赖通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 那么 scope 都可以有哪些取值呢？ 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile Y Y Y logback test - Y - Junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 system Y Y - 存储在本地的jar包 compile ：作用于编译环境、测试环境、运行环境。 test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值 provided ：作用于编译环境、测试环境。我们后面会学习 servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错 runtime ： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题 注意： 如果引入坐标不指定 scope 标签时，默认就是 compile 值。以后大部分jar包都是使用默认值。 2，Mybatis2.1 Mybatis概述2.1.1 Mybatis概念 MyBatis 是一款优秀的&#x3D;&#x3D;持久层框架&#x3D;&#x3D;，用于简化 JDBC 开发 MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github 官网：https://mybatis.org/mybatis-3/zh/index.html 持久层： 负责将数据到保存到数据库的那一层代码。 以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。 JavaEE三层架构：表现层、业务层、持久层 三层架构在后期会给大家进行讲解，今天先简单的了解下即可。 框架： 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 在框架的基础之上构建软件编写更加高效、规范、通用、可扩展 举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦 如下图所示有一个石膏娃娃，这个就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦 了解了什么是Mybatis后，接下来说说以前 JDBC代码 的缺点以及Mybatis又是如何解决的。 2.1.2 JDBC 缺点下面是 JDBC 代码，我们通过该代码分析都存在什么缺点： 硬编码 注册驱动、获取连接 上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。 SQL语句 上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。 操作繁琐 手动设置参数 手动封装结果集 上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。 2.1.3 Mybatis 优化 硬编码可以配置到&#x3D;&#x3D;配置文件&#x3D;&#x3D; 操作繁琐的地方mybatis都&#x3D;&#x3D;自动完成&#x3D;&#x3D; 如图所示 下图是持久层框架的使用占比。 2.2 Mybatis快速入门需求：查询user表中所有的数据 创建user表，添加数据 12345678910111213141516create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user( id int primary key auto_increment, username varchar(20), password varchar(20), gender char(1), addr varchar(30));INSERT INTO tb_user VALUES (1, &#x27;zhangsan&#x27;, &#x27;123&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);INSERT INTO tb_user VALUES (2, &#x27;李四&#x27;, &#x27;234&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;);INSERT INTO tb_user VALUES (3, &#x27;王五&#x27;, &#x27;11&#x27;, &#x27;男&#x27;, &#x27;西安&#x27;); 创建模块，导入坐标 在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加slf4j日志api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-classic依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-core依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：需要在项目的 resources 目录下创建logback的配置文件 编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题 在模块下的 resources 目录下创建mybatis的配置文件 mybatis-config.xml，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写 SQL 映射文件 –&gt; 统一管理sql语句，解决硬编码问题 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 编码 在 com.itheima.pojo 包下创建 User类 123456789public class User &#123; private int id; private String username; private String password; private String gender; private String addr; //省略了 setter 和 getter&#125; 在 com.itheima 包下编写 MybatisDemo 测试类 1234567891011121314151617public class MyBatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 解决SQL映射文件的警告提示： 在入门案例映射配置文件中存在报红的情况。问题如下： 产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。 解决方式：在Idea中配置MySQL数据库连接。 IDEA中配置MySQL数据库连接 点击IDEA右边框的 Database ，在展开的界面点击 + 选择 Data Source ，再选择 MySQL 在弹出的界面进行基本信息的填写 点击完成后就能看到如下界面 而此界面就和 navicat 工具一样可以进行数据库的操作。也可以编写SQL语句 2.3 Mapper代理开发2.3.1 Mapper代理开发概述之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下： 这里调用 selectList() 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。 通过上面的描述可以看出 Mapper 代理方式的目的： 解决原生方式中的硬编码 简化后期执行SQL Mybatis 官网也是推荐使用 Mapper 代理的方式。下图是截止官网的图片 2.3.2 使用Mapper代理要求使用Mapper代理方式，必须满足以下要求： 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图： 设置SQL映射文件的namespace属性为Mapper接口全限定名 在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 2.3.3 案例代码实现 在 com.itheima.mapper 包下创建 UserMapper接口，代码如下： 1234public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; 在 resources 下创建 com/itheima/mapper 目录，并在该目录下创建 UserMapper.xml 映射配置文件 123456789&lt;!-- namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 在 com.itheima 包下创建 MybatisDemo2 测试类，代码如下： 123456789101112131415161718192021222324/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql //3.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; &#x3D;&#x3D;注意：&#x3D;&#x3D; 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为 123456&lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt; 2.4 核心配置文件核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容 接下来我们先对里面的一些配置进行讲解。 2.4.1 多环境配置在核心配置文件的 environments 标签中其实是可以配置多个 environment ，使用 id 给每段环境起名，在 environments 中使用 default=&#39;环境id&#39; 来指定使用哪儿段配置。我们一般就配置一个 environment 即可。 1234567891011121314151617181920212223&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;= 2.4.2 类型别名在映射配置文件中的 resultType 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 类型别名(typeAliases) 可以简化这部分的书写。 首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下： 1234&lt;typeAliases&gt; &lt;!--name属性的值是实体类所在包--&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; 通过上述的配置，我们就可以简化映射配置文件中 resultType 属性值的编写 12345&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; Maven&amp;MyBatis目标 能够使用Maven进行项目的管理 能够完成Mybatis代理方式查询数据 能够理解Mybatis核心配置文件的配置 1，MavenMaven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构 提供了一套标准化的构建流程（编译，测试，打包，发布……） 提供了一套依赖管理机制 标准化的项目结构： 项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便，如下图:前两个是以后开发经常使用的开发工具 而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。 标准化的构建流程： 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 依赖管理： 依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包（当前之前是老师已经下载好提供给大家了），复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示 而Maven使用标准的 &#x3D;&#x3D;坐标&#x3D;&#x3D; 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。 如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。 市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比 1.1 Maven简介 &#x3D;&#x3D;Apache Maven&#x3D;&#x3D; 是一个项目管理和构建&#x3D;&#x3D;工具&#x3D;&#x3D;，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。 官网 ：http://maven.apache.org/ 通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。 1.1.1 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 插件(Plugin) 如上图所示就是Maven的模型，而我们先看紫色框框起来的部分，他就是用来完成 标准化构建流程 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。 上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目： 依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，如下图所示 上述Maven模型图中还有一部分是仓库。如何理解仓库呢？ 1.1.2 仓库大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。 仓库分类： 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 地址： https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 今天我们只学习远程仓库的使用，并不会搭建。 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包： 如果有，则在项目直接引用; 如果没有，则去中央仓库中下载对应的jar包到本地仓库。 如果还可以搭建远程仓库，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库 1.2 Maven安装配置 解压 apache-maven-3.6.1.rar 既安装完成 建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 D:\\software 下。 解压缩后的目录结构如下： bin目录 ： 存放的是可执行命令。mvn 命令重点关注。 conf目录 ：存放Maven的配置文件。settings.xml 配置文件后期需要修改。 lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。 配置环境变量 MAVEN_HOME 为安装路径的bin目录 此电脑 右键 –&gt; 高级系统设置 –&gt; 高级 –&gt; 环境变量 在系统变量处新建一个变量 MAVEN_HOME 在 Path 中进行配置 打开命令提示符进行验证，出现如图所示表示安装成功 配置本地仓库 修改 conf&#x2F;settings.xml 中的 为一个指定目录作为本地仓库，用来存储jar包。 配置阿里云私服 中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 修改 conf&#x2F;settings.xml 中的 标签，为其添加如下子标签： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; Maven基本使用1.3.1 Maven 常用命令 compile ：编译 clean：清理 test：测试 package：打包 install：安装 命令演示： 在 资料\\代码\\maven-project 提供了一个使用Maven构建的项目，项目结构如下： 而我们使用上面命令需要在磁盘上进入到项目的 pom.xml 目录下，打开命令提示符 编译命令演示： 1compile ：编译 执行上述命令可以看到： 从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件 在项目下会生成一个 target 目录 同时在项目下会出现一个 target 目录，编译后的字节码文件就放在该目录下 清理命令演示： 1mvn clean 执行上述命令可以看到 从阿里云下载清理需要的插件jar包 删除项目下的 target 目录 打包命令演示： 1mvn package 执行上述命令可以看到： 从阿里云下载打包需要的插件jar包 在项目的 terget 目录下有一个jar包（将当前项目打成的jar包） 测试命令演示： 1mvn test 该命令会执行所有的测试代码。执行上述命令效果如下 安装命令演示： 1mvn install 该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下： 1.3.2 Maven 生命周期Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven 对项目构建的生命周期划分为3套： clean ：清理工作。 default ：核心工作，例如编译，测试，打包，安装等。 site ： 产生报告，发布站点等。这套声明周期一般不会使用。 同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下： 当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test 命令，再执行 package 命令，最后执行 install 命令。 当我们执行 package （打包）命令时，它会先执行 compile 命令，再执行 test 命令，最后执行 package 命令。 默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的： 1.5.2 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。 如下图所示给 junit 依赖通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 那么 scope 都可以有哪些取值呢？ 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile Y Y Y logback test - Y - Junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 system Y Y - 存储在本地的jar包 compile ：作用于编译环境、测试环境、运行环境。 test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值 provided ：作用于编译环境、测试环境。我们后面会学习 servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错 runtime ： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题 注意： 如果引入坐标不指定 scope 标签时，默认就是 compile 值。以后大部分jar包都是使用默认值。 2.1 Mybatis概述2.1.1 Mybatis概念 MyBatis 是一款优秀的&#x3D;&#x3D;持久层框架&#x3D;&#x3D;，用于简化 JDBC 开发 MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github 官网：https://mybatis.org/mybatis-3/zh/index.html 持久层： 负责将数据到保存到数据库的那一层代码。 以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。 JavaEE三层架构：表现层、业务层、持久层 三层架构在后期会给大家进行讲解，今天先简单的了解下即可。 框架： 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 在框架的基础之上构建软件编写更加高效、规范、通用、可扩展 举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦 如下图所示有一个石膏娃娃，这个就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦 了解了什么是Mybatis后，接下来说说以前 JDBC代码 的缺点以及Mybatis又是如何解决的。 2.1.2 JDBC 缺点下面是 JDBC 代码，我们通过该代码分析都存在什么缺点： 硬编码 注册驱动、获取连接 上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。 SQL语句 上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。 操作繁琐 手动设置参数 手动封装结果集 上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。 2.1.3 Mybatis 优化 硬编码可以配置到&#x3D;&#x3D;配置文件&#x3D;&#x3D; 操作繁琐的地方mybatis都&#x3D;&#x3D;自动完成&#x3D;&#x3D; 如图所示 下图是持久层框架的使用占比。 2.2 Mybatis快速入门需求：查询user表中所有的数据 创建user表，添加数据 12345678910111213141516create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user( id int primary key auto_increment, username varchar(20), password varchar(20), gender char(1), addr varchar(30));INSERT INTO tb_user VALUES (1, &#x27;zhangsan&#x27;, &#x27;123&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);INSERT INTO tb_user VALUES (2, &#x27;李四&#x27;, &#x27;234&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;);INSERT INTO tb_user VALUES (3, &#x27;王五&#x27;, &#x27;11&#x27;, &#x27;男&#x27;, &#x27;西安&#x27;); 创建模块，导入坐标 在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加slf4j日志api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-classic依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-core依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：需要在项目的 resources 目录下创建logback的配置文件 编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题 在模块下的 resources 目录下创建mybatis的配置文件 mybatis-config.xml，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写 SQL 映射文件 –&gt; 统一管理sql语句，解决硬编码问题 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 编码 在 com.itheima.pojo 包下创建 User类 123456789public class User &#123; private int id; private String username; private String password; private String gender; private String addr; //省略了 setter 和 getter&#125; 在 com.itheima 包下编写 MybatisDemo 测试类 1234567891011121314151617public class MyBatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 解决SQL映射文件的警告提示： 在入门案例映射配置文件中存在报红的情况。问题如下： 产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。 解决方式：在Idea中配置MySQL数据库连接。 IDEA中配置MySQL数据库连接 点击IDEA右边框的 Database ，在展开的界面点击 + 选择 Data Source ，再选择 MySQL 在弹出的界面进行基本信息的填写 点击完成后就能看到如下界面 而此界面就和 navicat 工具一样可以进行数据库的操作。也可以编写SQL语句 2.3 Mapper代理开发2.3.1 Mapper代理开发概述之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下： 这里调用 selectList() 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。 通过上面的描述可以看出 Mapper 代理方式的目的： 解决原生方式中的硬编码 简化后期执行SQL Mybatis 官网也是推荐使用 Mapper 代理的方式。下图是截止官网的图片 2.3.2 使用Mapper代理要求使用Mapper代理方式，必须满足以下要求： 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图： 设置SQL映射文件的namespace属性为Mapper接口全限定名 在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 2.3.3 案例代码实现 在 com.itheima.mapper 包下创建 UserMapper接口，代码如下： 1234public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; 在 resources 下创建 com/itheima/mapper 目录，并在该目录下创建 UserMapper.xml 映射配置文件 123456789&lt;!-- namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 在 com.itheima 包下创建 MybatisDemo2 测试类，代码如下： 123456789101112131415161718192021222324/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql //3.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; &#x3D;&#x3D;注意：&#x3D;&#x3D; 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为 123456&lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt; 2.4 核心配置文件核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容 接下来我们先对里面的一些配置进行讲解。 2.4.1 多环境配置在核心配置文件的 environments 标签中其实是可以配置多个 environment ，使用 id 给每段环境起名，在 environments 中使用 default=&#39;环境id&#39; 来指定使用哪儿段配置。我们一般就配置一个 environment 即可。 1234567891011121314151617181920212223&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;= 2.4.2 类型别名在映射配置文件中的 resultType 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 类型别名(typeAliases) 可以简化这部分的书写。 首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下： 1234&lt;typeAliases&gt; &lt;!--name属性的值是实体类所在包--&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; 通过上述的配置，我们就可以简化映射配置文件中 resultType 属性值的编写 12345&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.tangyongao.top/categories/mysql/"}],"tags":[{"name":"mysql笔记","slug":"mysql笔记","permalink":"https://www.tangyongao.top/tags/mysql%E7%AC%94%E8%AE%B0/"}],"author":["唐 某 某"]},{"title":"hexo基本命令","slug":"hexo基本命令","date":"2022-11-13T16:47:56.000Z","updated":"2022-11-13T16:53:27.249Z","comments":true,"path":"2022/11/14/hexo基本命令/","link":"","permalink":"https://www.tangyongao.top/2022/11/14/hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"生成新文章：hexonew“文章名（标点符号为英文状态）会生成在source&#x2F;posts之下本地预览命令：hexos上传命令：hexog和hexod这两个个命令执行之后，网页就会自动更新","categories":[],"tags":[{"name":"基本命令","slug":"基本命令","permalink":"https://www.tangyongao.top/tags/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"}]},{"title":"markdown","slug":"markdown","date":"2022-10-16T04:54:29.000Z","updated":"2022-10-16T06:02:09.676Z","comments":true,"path":"2022/10/16/markdown/","link":"","permalink":"https://www.tangyongao.top/2022/10/16/markdown/","excerpt":"","text":"标题title1title2title3title4title5title6段落第一段落 物华天宝人杰地灵(如果想换行，就要在段落的末尾空两个空格或与下一段落空一行都可) 第二段落闾阎扑地，钟鸣鼎食之家 第三段落 但愿人长久，千里共婵娟 字体加粗是两个*（前后各两个）包围字即可 一个星号是斜体 粗斜体就是三个星号 分隔线三个*或者三个以上的- 下划线在markdown里面并没有关于下划线的语法，但是markdown允许你插入一些基本的HTML代码，下划线语法如下： 这是下划线 列表无序 A B a b a b 有序数字加上要写的东西就可以 a b c 有序和无序可以一起使用只要在下一行空四格即可 team1 a b 2.team2 + a + b 区块大于号加上你要写的东西即可，换行就空一行即可 区块1 区块2 区块嵌套就是标题的样式差不多，就是符号换成了&gt; 1 2 1 2 3 代码用留个点包裹住代码即可，如果代码高亮就需要根据hexo的代码来实现了 1System.out.println(&quot;代码&quot;) 链接直接写tangyonao.top 有时候会识别不出直接写的链接，就&lt;链接&gt;就能识别的出来了 第二种是blog 图片 表格第二行起到识别表格的作用 表头 表头 x x x x 转义字符*这样就可以写出*，不用担心被语法识别成别的东西","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.tangyongao.top/tags/markdown/"}]},{"title":"java笔记","slug":"java笔记","date":"2022-10-12T08:36:01.000Z","updated":"2023-03-10T15:18:08.693Z","comments":true,"path":"2022/10/12/java笔记/","link":"","permalink":"https://www.tangyongao.top/2022/10/12/java%E7%AC%94%E8%AE%B0/","excerpt":"","text":"javajava的诞生Java的第一个版本是在1995 sun正式发的 java之父是詹姆斯·高斯林 （James Gosling） JDK(java Development kit Java开发工具包);JDK&#x3D; JRE+JAVA的开发工具[java,javac,javadoc,javap等] JRE(Java Runtime Environment Java 运行环境) JRE &#x3D; JVM+Java的核心类库[类] $$","categories":[{"name":"java","slug":"java","permalink":"https://www.tangyongao.top/categories/java/"}],"tags":[{"name":"java笔记","slug":"java笔记","permalink":"https://www.tangyongao.top/tags/java%E7%AC%94%E8%AE%B0/"}],"author":["tangao"]},{"title":"测试12","slug":"测试12","date":"2022-10-11T08:24:06.000Z","updated":"2022-10-11T08:53:23.653Z","comments":true,"path":"2022/10/11/测试12/","link":"","permalink":"https://www.tangyongao.top/2022/10/11/%E6%B5%8B%E8%AF%9512/","excerpt":"","text":"注意事项：建议规范全站路径 URL 最后带一个 “&#x2F;“ 例如 “about&#x2F;“navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: volantis-static&#x2F;media&#x2F;org.volantis&#x2F;blog&#x2F;&#76;&#x6f;&#103;&#x6f;&#45;&#78;&#97;&#x76;&#66;&#97;&#114;&#x40;&#x33;&#120;&#x2e;&#112;&#x6e;&#x67; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: &#x2F; - name: 分类 icon: fa-solid fa-folder-open url: categories&#x2F; - name: 标签 icon: fa-solid fa-tags url: tags&#x2F; - name: 归档 icon: fa-solid fa-archive url: archives&#x2F; - name: 友链 icon: fa-solid fa-link url: friends&#x2F; - name: 关于 icon: fa-solid fa-info-circle url: about&#x2F; search: Search… # Search bar placeholder","categories":[],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE2/"}]},{"title":"测试","slug":"测试","date":"2022-10-11T08:23:58.000Z","updated":"2022-10-11T09:01:43.620Z","comments":true,"path":"2022/10/11/测试/","link":"","permalink":"https://www.tangyongao.top/2022/10/11/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"打的啊打的的aDas的","categories":[],"tags":[{"name":"标签3","slug":"标签3","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE3/"},{"name":"标签5","slug":"标签5","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE5/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://www.tangyongao.top/categories/Git/"},{"name":"linux","slug":"linux","permalink":"https://www.tangyongao.top/categories/linux/"},{"name":"Typora","slug":"Typora","permalink":"https://www.tangyongao.top/categories/Typora/"},{"name":"Spring","slug":"Spring","permalink":"https://www.tangyongao.top/categories/Spring/"},{"name":"mybatis","slug":"mybatis","permalink":"https://www.tangyongao.top/categories/mybatis/"},{"name":"mysql","slug":"mysql","permalink":"https://www.tangyongao.top/categories/mysql/"},{"name":"java","slug":"java","permalink":"https://www.tangyongao.top/categories/java/"}],"tags":[{"name":"Git笔记","slug":"Git笔记","permalink":"https://www.tangyongao.top/tags/Git%E7%AC%94%E8%AE%B0/"},{"name":"Linux笔记","slug":"Linux笔记","permalink":"https://www.tangyongao.top/tags/Linux%E7%AC%94%E8%AE%B0/"},{"name":"Linux软件安装","slug":"Linux软件安装","permalink":"https://www.tangyongao.top/tags/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Typora使用","slug":"Typora使用","permalink":"https://www.tangyongao.top/tags/Typora%E4%BD%BF%E7%94%A8/"},{"name":"Spring笔记","slug":"Spring笔记","permalink":"https://www.tangyongao.top/tags/Spring%E7%AC%94%E8%AE%B0/"},{"name":"mabatis 笔记","slug":"mabatis-笔记","permalink":"https://www.tangyongao.top/tags/mabatis-%E7%AC%94%E8%AE%B0/"},{"name":"mysql笔记","slug":"mysql笔记","permalink":"https://www.tangyongao.top/tags/mysql%E7%AC%94%E8%AE%B0/"},{"name":"基本命令","slug":"基本命令","permalink":"https://www.tangyongao.top/tags/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"name":"markdown","slug":"markdown","permalink":"https://www.tangyongao.top/tags/markdown/"},{"name":"java笔记","slug":"java笔记","permalink":"https://www.tangyongao.top/tags/java%E7%AC%94%E8%AE%B0/"},{"name":"标签1","slug":"标签1","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE2/"},{"name":"标签3","slug":"标签3","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE3/"},{"name":"标签5","slug":"标签5","permalink":"https://www.tangyongao.top/tags/%E6%A0%87%E7%AD%BE5/"}]}